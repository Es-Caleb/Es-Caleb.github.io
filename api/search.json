[{"id":"07be3b41822070c0f7b1cc1f18b34bdb","title":"Vue双向绑定实现原理","content":"前言原文：vue 的双向绑定原理及实现\n使用 vue 也好有一段时间了，虽然对其双向绑定原理也有了解个大概，但也没好好探究下其原理实现，所以这次特意花了几晚时间查阅资料和阅读相关源码，自己也实现一个简单版 vue 的双向绑定版本，先上个成果图来吸引各位：\n代码：\n\n效果图：\n\n是不是看起来跟 vue 的使用方式差不多？接下来就来从原理到实现，从简到难一步一步来实现这个 SelfVue。由于本文只是为了学习和分享，所以只是简单实现下原理，并没有考虑太多情况和设计，如果大家有什么建议，欢迎提出来。\n本文主要介绍两大内容：\n\nvue 数据双向绑定的原理。\n\n实现简单版 vue 的过程，主要实现v-model 和事件指令的功能。\n\n\n相关代码地址：github.com/canfoo/self…\nvue 数据双向绑定原理vue 数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的，那么 vue 是如果进行数据劫持的，我们可以先来看一下通过控制台输出一个定义在 vue 初始化数据上的对象是个什么东西。\n代码：\nvar vm = new Vue({\n  data: {\n    obj: {\n      a: 1,\n    },\n  },\n  created: function () {\n    console.log(this.obj);\n  },\n});\n\n结果：\n\n我们可以看到属性 a 有两个相对应的 get 和 set 方法，为什么会多出这两个方法呢？因为 vue 是通过 Object.defineProperty()来实现数据劫持的。\nObject.defineProperty( )是用来做什么的？它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举，这里我们主要先来研究下它对应的两个描述属性 get 和 set，如果还不熟悉其用法，请点击这里阅读更多用法。\n在平常，我们很容易就可以打印出一个对象的属性数据：\nvar Book = {\n  name: \"vue权威指南\",\n};\nconsole.log(Book.name); // vue权威指南\n\n如果想要在执行 console.log(book.name)的同时，直接给书名加个书名号，那要怎么处理呢？或者说要通过什么监听对象 Book 的属性值。这时候 Object.defineProperty( )就派上用场了，代码如下：\nvar Book = {};\nvar name = \"\";\nObject.defineProperty(Book, \"name\", {\n  set: function (value) {\n    name = value;\n    console.log(\"你取了一个书名叫做\" + value);\n  },\n  get: function () {\n    return \"《\" + name + \"》\";\n  },\n});\n\nBook.name = \"vue权威指南\"; // 你取了一个书名叫做vue权威指南\nconsole.log(Book.name); // 《vue权威指南》\n\n我们通过 Object.defineProperty( )设置了对象 Book 的 name 属性，对其 get 和 set 进行重写操作，顾名思义，get 就是在读取 name 属性这个值触发的函数，set 就是在设置 name 属性这个值触发的函数，所以当执行 Book.name = ‘vue 权威指南’ 这个语句时，控制台会打印出 “你取了一个书名叫做 vue 权威指南”，紧接着，当读取这个属性时，就会输出 “《vue 权威指南》”，因为我们在 get 函数里面对该值做了加工了。如果这个时候我们执行下下面的语句，控制台会输出什么？\nconsole.log(Book);\n\n结果：\n\n乍一看，是不是跟我们在上面打印 vue 数据长得有点类似，说明 vue 确实是通过这种方法来进行数据劫持的。接下来我们通过其原理来实现一个简单版的 mvvm 双向绑定代码。\n思路分析实现 mvvm 主要包含两个方面，数据变化更新视图，视图变化更新数据：\n\n关键点在于 data 如何更新 view，因为 view 更新 data 其实可以通过事件监听即可，比如 input 标签监听 ‘input’ 事件就可以实现了。所以我们着重来分析下，当数据改变，如何更新视图的。\n数据更新视图的重点是如何知道数据变了，只要知道数据变了，那么接下去的事都好处理。如何知道数据变了，其实上文我们已经给出答案了，就是通过 Object.defineProperty( )对属性设置一个 set 函数，当数据改变了就会来触发这个函数，所以我们只要将一些需要更新的方法放在这里面就可以实现 data 更新 view 了。\n\n思路有了，接下去就是实现过程了。\n实现过程我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器 Observer，用来监听所有属性。如果属性发生变化了，就需要告诉订阅者 Watcher 看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器 Dep 来专门收集这些订阅者，然后在监听器 Observer 和订阅者 Watcher 之间进行统一管理的。接着，我们还需要有一个指令解析器 Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者 Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者 Watcher 接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。因此接下去我们执行以下 3 个步骤，实现数据的双向绑定：\n1.实现一个监听器 Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。\n2.实现一个订阅者 Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。\n3.实现一个解析器 Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。\n流程图如下：\n\n1.实现一个 ObserverObserver 是一个数据监听器，其实现核心方法就是前文所说的 Object.defineProperty( )。如果要对所有属性都进行监听的话，那么可以通过递归方法遍历所有属性值，并对其进行 Object.defineProperty( )处理。如下代码，实现了一个 Observer。\nfunction defineReactive(data, key, val) {\n  observe(val); // 递归遍历所有子属性\n  Object.defineProperty(data, key, {\n    enumerable: true,\n    configurable: true,\n    get: function () {\n      return val;\n    },\n    set: function (newVal) {\n      val = newVal;\n      console.log(\n        \"属性\" + key + \"已经被监听了，现在值为：“\" + newVal.toString() + \"”\"\n      );\n    },\n  });\n}\n\nfunction observe(data) {\n  if (!data || typeof data !== \"object\") {\n    return;\n  }\n  Object.keys(data).forEach(function (key) {\n    defineReactive(data, key, data[key]);\n  });\n}\n\nvar library = {\n  book1: {\n    name: \"\",\n  },\n  book2: \"\",\n};\nobserve(library);\nlibrary.book1.name = \"vue权威指南\"; // 属性name已经被监听了，现在值为：“vue权威指南”\nlibrary.book2 = \"没有此书籍\"; // 属性book2已经被监听了，现在值为：“没有此书籍”\n\n思路分析中，需要创建一个可以容纳订阅者的消息订阅器 Dep，订阅器 Dep 主要负责收集订阅者，然后再属性变化的时候执行对应订阅者的更新函数。所以显然订阅器需要有一个容器，这个容器就是 list，将上面的 Observer 稍微改造下，植入消息订阅器：\nfunction defineReactive(data, key, val) {\n  observe(val); // 递归遍历所有子属性\n  var dep = new Dep();\n  Object.defineProperty(data, key, {\n    enumerable: true,\n    configurable: true,\n    get: function () {\n      if (是否需要添加订阅者) {\n        dep.addSub(watcher); // 在这里添加一个订阅者\n      }\n      return val;\n    },\n    set: function (newVal) {\n      if (val === newVal) {\n        return;\n      }\n      val = newVal;\n      console.log(\n        \"属性\" + key + \"已经被监听了，现在值为：“\" + newVal.toString() + \"”\"\n      );\n      dep.notify(); // 如果数据变化，通知所有订阅者\n    },\n  });\n}\n\nfunction Dep() {\n  this.subs = [];\n}\nDep.prototype = {\n  addSub: function (sub) {\n    this.subs.push(sub);\n  },\n  notify: function () {\n    this.subs.forEach(function (sub) {\n      sub.update();\n    });\n  },\n};\n\n从代码上看，我们将订阅器 Dep 添加一个订阅者设计在 getter 里面，这是为了让 Watcher 初始化进行触发，因此需要判断是否要添加订阅者，至于具体设计方案，下文会详细说明的。在 setter 函数里面，如果数据变化，就会去通知所有订阅者，订阅者们就会去执行对应的更新的函数。到此为止，一个比较完整 Observer 已经实现了，接下来我们开始设计 Watcher。\n2.实现 Watcher订阅者 Watcher 在初始化的时候需要将自己添加进订阅器 Dep 中，那该如何添加呢？我们已经知道监听器 Observer 是在 get 函数执行了添加订阅者 Wather 的操作的，所以我们只要在订阅者 Watcher 初始化的时候出发对应的 get 函数去执行添加订阅者操作即可，那要如何触发 get 的函数，再简单不过了，只要获取对应的属性值就可以触发了，核心原因就是因为我们使用了 Object.defineProperty( )进行数据监听。这里还有一个细节点需要处理，我们只要在订阅者 Watcher 初始化的时候才需要添加订阅者，所以需要做一个判断操作，因此可以在订阅器上做一下手脚：在 Dep.target 上缓存下订阅者，添加成功后再将其去掉就可以了。订阅者 Watcher 的实现如下：\nfunction Watcher(vm, exp, cb) {\n  this.cb = cb;\n  this.vm = vm;\n  this.exp = exp;\n  this.value = this.get(); // 将自己添加到订阅器的操作\n}\n\nWatcher.prototype = {\n  update: function () {\n    this.run();\n  },\n  run: function () {\n    var value = this.vm.data[this.exp];\n    var oldVal = this.value;\n    if (value !== oldVal) {\n      this.value = value;\n      this.cb.call(this.vm, value, oldVal);\n    }\n  },\n  get: function () {\n    Dep.target = this; // 缓存自己\n    var value = this.vm.data[this.exp]; // 强制执行监听器里的get函数\n    Dep.target = null; // 释放自己\n    return value;\n  },\n};\n\n这时候，我们需要对监听器 Observer 也做个稍微调整，主要是对应 Watcher 类原型上的 get 函数。需要调整地方在于 defineReactive 函数：\nfunction defineReactive(data, key, val) {\n  observe(val); // 递归遍历所有子属性\n  var dep = new Dep();\n  Object.defineProperty(data, key, {\n    enumerable: true,\n    configurable: true,\n    get: function() {\n      if (Dep.target) {.  // 判断是否需要添加订阅者\n        dep.addSub(Dep.target); // 在这里添加一个订阅者\n      }\n      return val;\n    },\n    set: function(newVal) {\n      if (val === newVal) {\n        return;\n      }\n      val = newVal;\n      console.log('属性' + key + '已经被监听了，现在值为：“' + newVal.toString() + '”');\n      dep.notify(); // 如果数据变化，通知所有订阅者\n    }\n  });\n}\nDep.target = null;\n\n到此为止，简单版的 Watcher 设计完毕，这时候我们只要将 Observer 和 Watcher 关联起来，就可以实现一个简单的双向绑定数据了。因为这里没有还没有设计解析器 Compile，所以对于模板数据我们都进行写死处理，假设模板上又一个节点，且 id 号为’name’，并且双向绑定的绑定的变量也为’name’，且是通过两个大双括号包起来（这里只是为了掩饰，暂时没什么用处），模板如下：\n&lt;body>\n  &lt;h1 id=\"name\">{{name}}&lt;/h1>\n&lt;/body>\n\n这时候我们需要将 Observer 和 Watcher 关联起来：\nfunction SelfVue(data, el, exp) {\n  this.data = data;\n  observe(data);\n  el.innerHTML = this.data[exp]; // 初始化模板数据的值\n  new Watcher(this, exp, function (value) {\n    el.innerHTML = value;\n  });\n  return this;\n}\n\n然后在页面上 new 以下 SelfVue 类，就可以实现数据的双向绑定了：\n&lt;body>\n  &lt;h1 id=\"name\">{{name}}&lt;/h1>\n&lt;/body>\n&lt;script src=\"js/observer.js\">&lt;/script>\n&lt;script src=\"js/watcher.js\">&lt;/script>\n&lt;script src=\"js/index.js\">&lt;/script>\n&lt;script type=\"text/javascript\">\n  var ele = document.querySelector(\"#name\");\n  var selfVue = new SelfVue(\n    {\n      name: \"hello world\",\n    },\n    ele,\n    \"name\"\n  );\n\n  window.setTimeout(function () {\n    console.log(\"name值改变了\");\n    selfVue.data.name = \"canfoo\";\n  }, 2000);\n&lt;/script>\n\n这时候打开页面，可以看到页面刚开始显示了是’hello world’，过了 2s 后就变成’canfoo’了。到这里，总算大功告成一半了，但是还有一个细节问题，我们在赋值的时候是这样的形式 ‘ selfVue.data.name = ‘canfoo’ ‘ 而我们理想的形式是’ selfVue.name = ‘canfoo’ ‘为了实现这样的形式，我们需要在 new SelfVue 的时候做一个代理处理，让访问 selfVue 的属性代理为访问 selfVue.data 的属性，实现原理还是使用 Object.defineProperty( )对属性值再包一层：\nfunction SelfVue(data, el, exp) {\n  var self = this;\n  this.data = data;\n\n  Object.keys(data).forEach(function (key) {\n    self.proxyKeys(key); // 绑定代理属性\n  });\n\n  observe(data);\n  el.innerHTML = this.data[exp]; // 初始化模板数据的值\n  new Watcher(this, exp, function (value) {\n    el.innerHTML = value;\n  });\n  return this;\n}\n\nSelfVue.prototype = {\n  proxyKeys: function (key) {\n    var self = this;\n    Object.defineProperty(this, key, {\n      enumerable: false,\n      configurable: true,\n      get: function proxyGetter() {\n        return self.data[key];\n      },\n      set: function proxySetter(newVal) {\n        self.data[key] = newVal;\n      },\n    });\n  },\n};\n\n这下我们就可以直接通过’ selfVue.name = ‘canfoo’ ‘的形式来进行改变模板数据了。如果想要迫切看到现象的童鞋赶快来获取代码！\n3.实现 Compile虽然上面已经实现了一个双向数据绑定的例子，但是整个过程都没有去解析 dom 节点，而是直接固定某个节点进行替换数据的，所以接下来需要实现一个解析器 Compile 来做解析和绑定工作。解析器 Compile 实现步骤：\n1.解析模板指令，并替换模板数据，初始化视图\n2.将模板指令对应的节点绑定对应的更新函数，初始化相应的订阅器\n为了解析模板，首先需要获取到 dom 元素，然后对含有 dom 元素上含有指令的节点进行处理，因此这个环节需要对 dom 操作比较频繁，所有可以先建一个 fragment 片段，将需要解析的 dom 节点存入 fragment 片段里再进行处理：\nfunction nodeToFragment(el) {\n  var fragment = document.createDocumentFragment();\n  var child = el.firstChild;\n  while (child) {\n    // 将Dom元素移入fragment中\n    fragment.appendChild(child);\n    child = el.firstChild;\n  }\n  return fragment;\n}\n\n接下来需要遍历各个节点，对含有相关指定的节点进行特殊处理，这里咱们先处理最简单的情况，只对带有 ‘‘ 这种形式的指令进行处理，先简道难嘛，后面再考虑更多指令情况：\nfunction compileElement (el) {\n  var childNodes = el.childNodes;\n  var self = this;\n  [].slice.call(childNodes).forEach(function(node) {\n    var reg = /\\{\\{(.*)\\}\\}/;\n    var text = node.textContent;\n\n    if (self.isTextNode(node) &amp;&amp; reg.test(text)) {  // 判断是否是符合这种形式{{}}的指令\n      self.compileText(node, reg.exec(text)[1]);\n    }\n\n    if (node.childNodes &amp;&amp; node.childNodes.length) {\n      self.compileElement(node);  // 继续递归遍历子节点\n    }\n  });\n},\nfunction compileText (node, exp) {\n  var self = this;\n  var initText = this.vm[exp];\n  this.updateText(node, initText);  // 将初始化的数据初始化到视图中\n  new Watcher(this.vm, exp, function (value) {  // 生成订阅器并绑定更新函数\n    self.updateText(node, value);\n  });\n},\nfunction (node, value) {\n  node.textContent = typeof value == 'undefined' ? '' : value;\n}\n```\n\n获取到最外层节点后，调用 compileElement 函数，对所有子节点进行判断，如果节点是文本节点且匹配{{}}这种形式指令的节点就开始进行编译处理，编译处理首先需要初始化视图数据，对应上面所说的步骤 1，接下去需要生成一个并绑定更新函数的订阅器，对应上面所说的步骤 2。这样就完成指令的解析、初始化、编译三个过程，一个解析器 Compile 也就可以正常的工作了。为了将解析器 Compile 与监听器 Observer 和订阅者 Watcher 关联起来，我们需要再修改一下类 SelfVue 函数：\n\n```js\nfunction SelfVue(options) {\n  var self = this;\n  this.vm = this;\n  this.data = options;\n\n  Object.keys(this.data).forEach(function (key) {\n    self.proxyKeys(key);\n  });\n\n  observe(this.data);\n  new Compile(options, this.vm);\n  return this;\n}\n\n更改后，我们就不要像之前通过传入固定的元素值进行双向绑定了，可以随便命名各种变量进行双向绑定了：\n&lt;body>\n  &lt;div id=\"app\">\n    &lt;h2>{{title}}&lt;/h2>\n    &lt;h1>{{name}}&lt;/h1>\n  &lt;/div>\n&lt;/body>\n&lt;script src=\"js/observer.js\">&lt;/script>\n&lt;script src=\"js/watcher.js\">&lt;/script>\n&lt;script src=\"js/compile.js\">&lt;/script>\n&lt;script src=\"js/index.js\">&lt;/script>\n&lt;script type=\"text/javascript\">\n  var selfVue = new SelfVue({\n    el: \"#app\",\n    data: {\n      title: \"hello world\",\n      name: \"\",\n    },\n  });\n\n  window.setTimeout(function () {\n    selfVue.title = \"你好\";\n  }, 2000);\n\n  window.setTimeout(function () {\n    selfVue.name = \"canfoo\";\n  }, 2500);\n&lt;/script>\n\n如上代码，在页面上可观察到，刚开始 titile 和 name 分别被初始化为 ‘hello world’ 和空，2s 后 title 被替换成 ‘你好’ 3s 后 name 被替换成 ‘canfoo’ 了。废话不多说，再给你们来一个这个版本的代码（v2），获取代码！\n到这里，一个数据双向绑定功能已经基本完成了，接下去就是需要完善更多指令的解析编译，在哪里进行更多指令的处理呢？答案很明显，只要在上文说的 compileElement 函数加上对其他指令节点进行判断，然后遍历其所有属性，看是否有匹配的指令的属性，如果有的话，就对其进行解析编译。这里我们再添加一个 v-model 指令和事件指令的解析编译，对于这些节点我们使用函数 compile 进行解析处理：\nfunction compile(node) {\n  var nodeAttrs = node.attributes;\n  var self = this;\n  Array.prototype.forEach.call(nodeAttrs, function (attr) {\n    var attrName = attr.name;\n    if (self.isDirective(attrName)) {\n      var exp = attr.value;\n      var dir = attrName.substring(2);\n      if (self.isEventDirective(dir)) {\n        // 事件指令\n        self.compileEvent(node, self.vm, exp, dir);\n      } else {\n        // v-model 指令\n        self.compileModel(node, self.vm, exp, dir);\n      }\n      node.removeAttribute(attrName);\n    }\n  });\n}\n\n上面的 compile 函数是挂载 Compile 原型上的，它首先遍历所有节点属性，然后再判断属性是否是指令属性，如果是的话再区分是哪种指令，再进行相应的处理，处理方法相对来说比较简单，这里就不再列出来，想要马上看阅读代码的同学可以马上点击这里获取。\n最后我们在稍微改造下类 SelfVue，使它更像 vue 的用法：\nfunction SelfVue(options) {\n  var self = this;\n  this.data = options.data;\n  this.methods = options.methods;\n\n  Object.keys(this.data).forEach(function (key) {\n    self.proxyKeys(key);\n  });\n\n  observe(this.data);\n  new Compile(options.el, this);\n  options.mounted.call(this); // 所有事情处理好后执行mounted函数\n}\n\n这时候我们可以来真正测试了，在页面上设置如下东西：\n&lt;body>\n  &lt;div id=\"app\">\n    &lt;h2>{{title}}&lt;/h2>\n    &lt;input v-model=\"name\" />\n    &lt;h1>{{name}}&lt;/h1>\n    &lt;button v-on:click=\"clickMe\">click me!&lt;/button>\n  &lt;/div>\n&lt;/body>\n&lt;script src=\"js/observer.js\">&lt;/script>\n&lt;script src=\"js/watcher.js\">&lt;/script>\n&lt;script src=\"js/compile.js\">&lt;/script>\n&lt;script src=\"js/index.js\">&lt;/script>\n&lt;script type=\"text/javascript\">\n  new SelfVue({\n    el: \"#app\",\n    data: {\n      title: \"hello world\",\n      name: \"canfoo\",\n    },\n    methods: {\n      clickMe: function () {\n        this.title = \"hello world\";\n      },\n    },\n    mounted: function () {\n      window.setTimeout(() => {\n        this.title = \"你好\";\n      }, 1000);\n    },\n  });\n&lt;/script>\n\n是不是看起来跟 vue 的使用方法一样，哈，真正的大功告成！想要代码，直接点击这里获取！现象还没描述？直接上图！！！请观赏\n\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检 ing】》\n","slug":"vue-two-way-binding","date":"2023-02-22T09:11:15.000Z","categories_index":"前端,自检清单,Vue","tags_index":"前端,自检清单,Vue","author_index":"手可摘星陈"},{"id":"1bcb72c46f3db03b6d18568be7cdb3be","title":"描述new一个对象的详细过程，手动实现一个new操作符","content":"定义\n\n\n\n\n\n\n\n\nnew 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。 (MDN)\n操作\n创建一个空的简单JavaScript对象（即{}）；\n链接该对象（即设置该对象的构造函数）到另一个对象 ；\n将步骤1新创建的对象作为this的上下文 ；\n如果该函数没有返回对象，则返回this。\n\n语法Object = new constructor([argument])\n模拟实现/**\n * 模仿new关键词实现\n * @param {Function} constructor 构造函数\n * @param  {...any} argument 任意参数\n */\nconst _new =  (constructor,...argument) => { \n    const obj = {} //创建一个空的简单对象 \n    obj.__proto__ = constructor.prototype //设置原型\n    const res = constructor.apply(obj, argument) //新创建的对象作为this的上下文传递给构造函数\n    return (typeof res === 'object') ? res : obj //如果该函数没有返回对象，则返回this(这个this指constructor执行时内部的this,即res))。 \n}\n\nfunction Person(name,sex){\n    this.name = name \n    this.sex = sex\n}\n\nconst people = new Person('Ben','man');\nconst peopleOther = _new(Person,'Alice','woman');\nconsole.info('people',people);// people Person { name: 'Ben', sex: 'man' }\nconsole.info('peopleOther',peopleOther);// peopleOther Person { name: 'Alice', sex: 'woman' }\nconsole.info('people.__proto__',people.__proto__);//people.__proto__ Person {}\nconsole.info('peopleOther.__proto__',peopleOther.__proto__);//peopleOther.__proto__ Person {}\n\n可以看到 返回结果结构一致 同时Constructor和原型也一致\n原文：《描述new一个对象的详细过程以及手动实现一个new操作符》\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"new-operator","date":"2023-02-22T08:47:43.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"a9932dfc783681953ee77924badfcfab","title":"一名【合格】前端工程师的自检清单【自检ing】","content":"前言感谢原作者提供这样一份优秀的自检清单，写这篇的文章的主要目的是按照清单上的知识检测自己还有哪些不足和提升，同时建立自己的知识体系原文章地址: 一名【合格】前端工程师的自检清单\n\n一、JavaScript基础\n\n\n\n\n\n\n\n\n前端工程师吃饭的家伙，深度、广度一样都不能差。\n变量和类型\n1.JavaScript规定了几种语言类型\n2.JavaScript对象的底层数据结构是什么\n3.Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol\n4.JavaScript中的变量在内存中的具体存储形式\n5.基本类型对应的内置对象，以及他们之间的装箱拆箱操作\n6.理解值类型和引用类型\n7.null和undefined的区别\n8.至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型\n9.可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用\n10.出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法\n\n原型和原型链\n1.理解原型设计模式以及JavaScript中的原型规则\n2.instanceof的底层实现原理，手动实现一个instanceof\n3.实现继承的几种方式以及他们的优缺点\n4.至少说出一种开源项目(如Node)中应用原型继承的案例\n5.可以描述new一个对象的详细过程，手动实现一个new操作符\n6.理解es6 class构造以及继承的底层实现原理\n\n六、框架和类库\n\n\n\n\n\n\n\n\n轮子层出不穷，从原理上理解才是正道\nVue\n1.熟练使用Vue的API、生命周期、钩子函数\n2.MVVM框架设计理念\n3.Vue双向绑定实现原理、Diff算法的内部实现\n4.Vue的事件机制\n5.从template转换成真实DOM的实现机制\n\n","slug":"self-check-list","date":"2023-02-14T02:15:00.000Z","categories_index":"前端,自检清单","tags_index":"前端,自检清单","author_index":"手可摘星陈"},{"id":"adfd6df2d42caf12c71977a2781bb441","title":"实现继承的几种方式以及他们的优缺点","content":"原文：《JS实现继承的几种方法总结》\n一、基本代码首先定义一个父类：\n//构造函数\nfunction Animal(name) {\n  this.name = name || 'Animal';\n  this.sleep = function() {\n    console.log(this.name + '正在睡觉！');\n  };\n}\n//原型上面的方法：\nAnimal.prototype.eat = function(food) {\n  console.log(this.name + '正在吃:' + food);\n}\n\n二、实现继承的方法原型链继承//核心：将父类的实例作为子类的原型\nfunction Dog() {\n\n}\nDog.prototype = new Animal();  //将Animal的实例挂载到了Dog的原型链上\n//或：\n//Dog.prototype = Object.create(Animal.prototype)\nDog.prototype.name = 'dog';\n\nvar dog = new Dog();\nconsole.log(dog.name);  //dog\ndog.eat('bone');  //dog正在吃:bone\ndog.sleep();  //dog正在睡觉！\nconsole.log(dog instanceof Animal); //true\nconsole.log(dog instanceof Dog);  //true\n\n特点：\n\n非常纯粹的继承关系，实例是子类的实例，也是父类的实例\n父类新增原型方法/原型属性，子类都能访问的到\n简单\n\n缺点：\n\n要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中\n无法实现继承多个\n来自原型对象的所有属性被所有实例共享\n创建子类实例时，无法向父类构造函数传参\n\n构造继承//核心：使用父类的构造函数增强子类实例，等于是复制父类的实例属性给子类（没用到原型）\nfunction Cat(name) {\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n\nvar cat = new Cat();\nconsole.log(cat.name);  //Tom\ncat.sleep();  //Tom正在睡觉！\nconsole.log(cat instanceof Animal); //false\nconsole.log(cat instanceof Cat);  //true\n\n特点：\n\n创建子类实例时，可以向父类传递参数\n可以实现多继承（call多个父类对象）\n\n缺点：\n\n实例并不是父类的实例，只是子类的实例\n只能继承父类的实例属性和方法，不能继承原型属性/方法\n无法实现函数复用，每个子类都有父类实例函数的副本，影响性能\n\n实例继承//核心：为父类实例添加新特性，作为子类实例返回\nfunction Cat(name) {\n  var instance = new Animal();\n  instance.name = name || 'Tom';\n  return instance;\n}\n\nvar cat = new Cat();\nconsole.log(cat.name);  //Tom\ncat.sleep();  //Tom正在睡觉！\nconsole.log(cat instanceof Animal); //true\nconsole.log(cat instanceof Cat);  //false\n\n特点：\n\n不限制调用方式，不管是new子类()还是子类()，返回的对象都具有相同的效果\n\n缺点：\n\n实例是父类的实例，不是子类的实例\n不支持多继承\n\n拷贝继承function Cat(name){\n  var animal = new Animal();\n  for(let i in animal) {\n    Cat.prototype[i] = animal[i];\n  }\n  Cat.prototype.name = name || 'Tom';\n}\n\nvar cat = new Cat();\nconsole.log(cat.name);  //Tom\ncat.sleep();  //Tom正在睡觉！\nconsole.log(cat instanceof Animal);  // false\nconsole.log(cat instanceof Cat);  // true\n\n特点：\n\n支持多继承\n\n缺点：\n\n效率极低，内存占用高（因为要拷贝父类的属性）\n无法获取父类不可枚举的方法（for in不能访问到的）\n\n组合继承//核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\nfunction Cat(name) {\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\nCat.prototype = new Animal();\nCat.prototype.constructor = Cat;\n\nvar cat = new Cat();\nconsole.log(cat.name);  //Tom\ncat.sleep();  //Tom正在睡觉\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat);  // true\n\n特点：\n\n弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法\n既是子类的实例，也是父类的实例\n不存在引用属性共享问题\n函数可复用\n可传参\n\n缺点：\n\n调用了俩次构造函数，生成了俩份实例（子类实例将子类原型上的那份屏蔽了）\n\n寄生组合继承//核心：通过寄生方式，砍掉父类的实例属性，这样，在调用俩次父类的构造的时候，就不会初始化俩次实例方法/属性，避免了组合继承的缺点。\nfunction Cat(name) {\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n(function() {\n  var Super = function() {};  //创建一个没有实例的方法类。\n  Super.prototype = Animal.prototype;\n  Cat.prototype = new Super();  //将实例作为子类的原型。\n})();\n\nlet cat = new Cat();\nconsole.log(cat.name);  //Tom\ncat.sleep();  //Tom正在睡觉\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat);  //true\n\nCat.prototype.constructor = Cat;  //修复构造函数\n\n特点：\n\n基本上是完美的\n\n缺点：\n\n实现起来较为复杂\n\nclass - extends - - ES6语法糖，底层任然是原型链继承的方式https://es6.ruanyifeng.com/#docs/class-extends\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"inherit","date":"2023-02-22T07:33:20.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"16a4b519aa491c4cff8a204db9c74eba","title":"instanceof的底层实现原理，手动实现一个instanceof","content":"instanceof 的作用\n\n\n\n\n\n\n\n\n引用数据类型判断： 用来判断一个引用数据类型是否属于构造函数\n继承关系判断： 用来判断一个实例是否属于它的父类型\n实现原理\n\n\n\n\n\n\n\n\n首先判断左边的变量的隐式原型(proto)是否全等于右边的显式原型(prototype)，如果相等返回true，如果不等则沿着原型链依次向上进行判断，如果都不等则返回false\n手动实现 instanceoffunction instance_of (L, R) { //L 表示左表达式，R 表示右表达式\n  var O = R.prototype;\n  L = L.__proto__;\n  while(true) {\n    if ( L === null ) return false;\n    if ( O === L ) return true; // 这里重点：当 O 严格等于 L 时，返回true \n    L = L.__proto__;\n  }\n}\n\n参考：《instanceof的底层实现原理，手动实现一个instanceof》\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"instanceof-realize","date":"2023-02-22T06:09:55.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"3d0e05ad397f90d89d1de00301c0be95","title":"Vue的API、生命周期、钩子函数","content":"API具体详情进：Vue API\n常用的如：\n`// console.log(vm.$root);`\n`vm.$root``//实例对象`\n\n`vm.$el``//根元素（真实的DOM元素）`\n`// console.log(vm.$el);`\n\n`vm.$el.innerHTML``//得到根元素（真实的DOM元素）中的内容`\n`// console.log(vm.$el.innerHTML);`\n\n`vm.$data``//实例下的data对象`\n`// console.log(vm.$data);`\n\n`vm.$options``//实例下的挂载项`\n`// console.log(vm.$options);`\n\n`vm.$props``//组件之间通信的数据`\n`// console.log(vm.$props);`\n\n`vm.$parent``//在组件中，指父元素`\n`// console.log(vm.$parent);`\n\n`vm.$children``//在组件中，指子代元素`\n`// console.log(vm.$children);`\n\n`vm.$attrs``//用来获取父组件传递过来的所有属性`\n`// console.log(vm.$attrs);`\n\n`vm.$listeners``//用来获取父组件传递过来的所有方法`\n`// console.log(vm.$listeners);`\n\n`vm.$slots``//组件中的插槽`\n`// console.log(vm.$slots);`\n\n`vm.$scopedSlots``//用来访问作用域插槽`\n`// console.log(vm.$scopedSlots);`\n\n`vm.$refs``//用来定位DOM元素（使用ref进行追踪）`\n`// console.log(vm.$refs);`\n\n`vm.$watch``//用于监听数据（在vue文件中使用后会自动销毁）`\n`// console.log(vm.$watch);`\n\n`vm.$emit``//用于派发事件（常用于数据通信）`\n`// console.log(vm.$emit);`\n\n`vm.$on``//用于监听事件的派发`\n`// console.log(vm.$on);`\n\n`vm.$once``//只监听事件一次（之后不监听）`\n`// console.log(vm.$once);`\n\n生命周期\n\n\n生命周期\n描述\n\n\n\nbeforeCreate\n组件实例被创建之初\n\n\ncreated\n组件实例已经完全创建\n\n\nbeforeMount\n组件挂载之前\n\n\nmounted\n组件挂载到实例上去之后\n\n\nbeforeUpdate\n组件数据发生变化，更新之前\n\n\nupdated\n组件数据更新之后\n\n\nbeforeDestroy\n组件实例销毁之前\n\n\ndestroyed\n组件实例销毁之后\n\n\nactivated\nkeep-alive 缓存的组件激活时\n\n\ndeactivated\nkeep-alive 缓存的组件停用时调用\n\n\nerrorCaptured\n捕获一个来自子孙组件的错误时被调用\n\n\nVue生命周期流程图\n\n钩子函数总共有11个\n\nbeforeCreate created[可以获取数据及方法]\n\nbeforeMount mounted[可以获取到真实的DOM]\n\nbeforeUpdate updated[数据更新执行]\n\nbeforeDestroy destroyed[销毁vue实例，不再具有双向数据绑定的特点]\n\n当keep-alive 缓存组件才会有的生命周期的钩子函数\n\nactivated deactivated\n\n\nerrorCaptured 当子孙组件出错时，会调用这个钩子函数\n\n\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"vue-api","date":"2023-02-21T03:41:36.000Z","categories_index":"前端,自检清单,Vue","tags_index":"前端,自检清单,Vue","author_index":"手可摘星陈"},{"id":"72e4b58e2d3b566d6790462e8f45cacc","title":"MVVM框架设计理念","content":"前言目前比较流行的几个框架，例如vue.js、react.js、avalon、angular.js等，给自己的定位都是属于mvvm类型框架，那么什么是mvvm框架呢？mvvm是什么意思呢？\n聊到mvvm就要提一下java语言中的mvc模式，所以我们想来看下什么是mvc。\nMVC概要这是苹果开发者文档中摘过来的图片，表明了三者之间的关系，简单描述了三者作用\nModel：数据模型，用来存储数据\nView：视图界面，用来展示UI界面和响应用户交互\nController：控制器(大管家角色)，监听模型数据的改变和控制视图行为、处理用户交互\nview操作会触发controller去改变model，然后model再去改变视图，这么以来，三个部分代码都分开来写，逻辑就会清晰很多；mvvm就是基于这种设计理念，来创新的提出mvvm这种开发理念来处理前端开发，可以说mvvm就是相当于前端的mvc，下面就来说下mvvm。\nMVVMmvvm即Model-View-ViewModel，mvvm的设计原理是基于mvc的，所以说mvvm不算是一种创新，充其量是一种改造，这其中的ViewModel便是一个小小的创新；如下图所示：以上图中可看出三者之间的关系；可以将ViewMode看作是Model和View的连接桥，View可以通过事件绑定Model，Model可以通过数据绑定View，通过ViewMode可以实现数据和视图的完全分离。\n\n\n\n\n\n\n\n\n\n参考：什么是mvvm设计模式\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"mvvm-design-concept","date":"2023-02-21T03:09:01.000Z","categories_index":"前端,自检清单,Vue","tags_index":"前端,自检清单,Vue","author_index":"手可摘星陈"},{"id":"9c0e46ac234b95fe1f1741ca7e4e7d0c","title":"理解原型设计模式以及JavaScript中的原型规则","content":"原型规则原型规则所有的引用类型（数组、对象、函数），都具有对象特征，即可自由扩展属性；\nvar arr = []; arr.a =1;\n\n\n所有的引用类型都有对象的特性，即可自由扩展\n所有的引用类型都有一个_proto_属性（隐式原型），属性的值是一个普通对象\n所有函数，都具有一个prototype（显示原型），属性值也是一个普通原型\n所有的引用类型（数组、对象、函数），其隐式原型指向其构造函数的显式原型；（obj.proto === Object.prototype）\n当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么回去它的_proto_（即它的构造函数的prototype）中去寻找原型对象prototype 在js中，函数对象其中一个属性：原型对象prototype。普通对象没有prototype属性，但有_proto_属性。 原型的作用就是给这个类的每一个对象都添加一个统一的方法，在原型中定义的方法和属性都是被所以实例对象所共享。var person = function(name){\n  this.name = name\n};\nperson.prototype.getName=function(){//通过person.prototype设置函数对象属性\n  return this.name; \n}\nvar crazy= new person(‘crazyLee’);\ncrazy.getName(); //crazyLee//crazy继承上属性\n\n原型链当试图得到一个对象f的某个属性时，如果这个对象本身没有这个属性，那么会去它的_proto_（即它的构造函数的prototype）obj._proto_中去寻找；当obj._proto也没有时，便会在obj._proto.proto（即obj的构造函数的prototype的构造函数的prototype）中寻找设计模式工厂模式在函数内创建一个对象，给对象赋予属性及方法再将对象返回``` jsfunction Person() {  var People = new Object();  People.name = ‘CrazyLee’;  People.age = ‘25’;  People.sex = function(){  return &#39;boy&#39;;\n\n  };  return People;}\n\nvar a = Person();console.log(a.name);//CrazyLeeconsole.log(a.sex());//boy\n## 构造函数模式\n无需在函数内部重新创建对象，而是用this指代\n``` js\nfunction Person() &#123;\n    this.name = &#39;CrazyLee&#39;;\n    this.age = &#39;25&#39;;\n    this.sex = function()&#123;\n        return &#39;boy&#39;\n    &#125;;\n    \n&#125;\n\nvar a = new Person();\nconsole.log(a.name);//CrazyLee\nconsole.log(a.sex());//boy\n\n原型模式函数中不对属性进行定义，利用prototype属性对属性进行定义，可以让所有对象实例共享它所包含的属性及方法\nfunction Parent() {\n    Parent.prototype.name = 'carzy';\n    Parent.prototype.age = '24';\n    Parent.prototype.sex = function() {\n    &amp;emsp;var s=\"女\";\n\n&amp;emsp;&amp;emsp;&amp;emsp; console.log(s);\n    }\n}\n\nvar  x =new  Parent();  \nconsole.log(x.name);      //crazy\nconsole.log(x.sex());       //女\n\n混合模式原型模式+构造函数模式。这种模式中，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性\nfunction Parent(){  \n    this.name=\"CrazyLee\";  \n    this.age=24;  \n};\nParent.prototype.sayname=function(){  \n    return this.name;  \n};\n\nvar x =new Parent(); \nconsole.log(x.sayname());   //Crazy&amp;emsp;&amp;emsp;\n\n动态原型模式将所有信息封装在了构造函数中，而通过构造函数中初始化原型，这个可以通过判断该方法是否有效而选择是否需要初始化原型\nfunction Parent(){  \n    this.name=\"CrazyLee\";  \n    this.age=24;  \n    if(typeof Parent._sayname==\"undefined\"){     \n        Parent.prototype.sayname=function(){  \n            return this.name;  \n        }  \n        Parent._sayname=true;  \n    }         \n};   \n\nvar x =new Parent();  \nconsole.log(x.sayname()); \n\n\n\n\n\n\n\n\n\n\n 参考：《原型设计模式以及JavaScript中的原型规则》\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"prototype-rules","date":"2023-02-20T08:10:45.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"97ef40e42114f03cdf27cd3432d76d80","title":"出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法","content":"一个经典的面试题\n0.1 + 0.2 === 0.3 // false\n\n精度丢失原因计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。\n0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数。\nJavaScript 中数字的存储遵循 IEEE 754 标准，是以 64 位双精度格式来存储数字的。\n一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。\n  根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：0.30000000000000004。\n最大数字、最大安全数\n能够表示的最大数字Number.MAX_VALUE等于1.7976931348623157e+308\n\n最大安全数字Number.MAX_SAFE_INTEGER等于9007199254740991\n\n\nJS处理最大数字的方法json-bigint官方示例\nvar JSONbig = require('json-bigint');\nvar JSONstrict = require('json-bigint')({ strict: true });\n\nvar dupkeys = '{ \"dupkey\": \"value 1\", \"dupkey\": \"value 2\"}';\nconsole.log('\\n\\nDuplicate Key test with both lenient and strict JSON parsing');\nconsole.log('Input:', dupkeys);\nvar works = JSONbig.parse(dupkeys);\nconsole.log('JSON.parse(dupkeys).dupkey: %s', works.dupkey);\nvar fails = 'will stay like this';\ntry {\n  fails = JSONstrict.parse(dupkeys);\n  console.log('ERROR!! Should never get here');\n} catch (e) {\n  console.log(\n    'Succesfully catched expected exception on duplicate keys: %j',\n    e\n  );\n}\n\n// 这些事打印内容\nDuplicate Key test with big number JSON\nInput: { \"dupkey\": \"value 1\", \"dupkey\": \"value 2\"}\nJSON.parse(dupkeys).dupkey: value 2\nSuccesfully catched expected exception on duplicate keys: {\"name\":\"SyntaxError\",\"message\":\"Duplicate key \\\"dupkey\\\"\",\"at\":33,\"text\":\"{ \\\"dupkey\\\": \\\"value 1\\\", \\\"dupkey\\\": \\\"value 2\\\"}\"}\n\n参考：js大数字精度丢失问题\n处理精度缺失的方法toPrecision +s parseFloat使用 toPrecision 凑整并 parseFloat转成数字后再显示\n// 示例\nparseFloat(1.4000000000000001.toPrecision(12)) === 1.4  // True\n\n封装成方法就是：\nfunction strip(num, precision = 12) {\n  return +parseFloat(num.toPrecision(precision));\n}\n\nNumber.EPSILON在ES6中，提供了Number.EPSILON属性，而它的值就是2-52，只要判断0.1+0.2-0.3是否小于Number.EPSILON，如果小于，就可以判断为0.1+0.2 ===0.3\nfunction numberepsilon(arg1, arg2){ \n    return Math.abs(arg1 - arg2) &lt; Number.EPSILON;\n} \nconsole.log(numberepsilon(0.1 + 0.2, 0.3)); // true\n\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"loss-of-precision","date":"2023-02-17T09:17:28.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"8df75aa3038e84f242f016eb70dbbb6a","title":"可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用","content":"数值转换有三个函数可以将非数值转换为数值：Number()、parseInt()、parseFloat()。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。\n隐式类型转换\n涉及类型转换最多的两个运算符是+和==。+可以是字符串相加，也可以是数字相加，在操作符中存在字符串时，优先转换为字符串。\n−∗/- * /−∗/ 只针对Number类型，所以转换的结果只能是Number类型。\n\n三种转换转换为数字\n\n\n\n\n\n\n\n\nES定义所有对象都有toString()方法，无论它是伪对象还是对象。\n\n\n\n参数\n结果\n\n\n\nstring\n解析为数字，含有除了数字之外的字符，则转换为NAN\n\n\nboolean\ntrue-&gt;1 false-&gt;0\n\n\nundefined\nNAN\n\n\nnull\n+0\n\n\n[]\n+0\n\n\n[5]\n5\n\n\n{}\nNAN\n\n\n‘111’\n111 空字符串转为0 含有字符的字符串转为NaN\n\n\nSymbol\n报错\n\n\n转换为字符串\n\n\n参数\n结果\n\n\n\nboolean\ntrue-&gt;’true’ false-&gt;’false’\n\n\nundefined\n‘undefined’\n\n\nnull\n‘null’\n\n\nNumber\n直接转换，例如123-&gt;’123’\n\n\n[]\n“”\n\n\n[5,2]\n“5.2”\n\n\n{}\n‘[Object Object]’\n\n\nSymbol\n‘Symbol()’\n\n\n转换为布尔值\n\n\n参数\n结果\n\n\n\nstring\n除了空串都是’true’\n\n\nundefined\nfalse\n\n\nnull\nfalse\n\n\nNumber\n除了+0 -0 NaN之外其他都为true\n\n\n[]\ntrue\n\n\n{}\ntrue\n\n\nSymbol\ntrue\n\n\n===的判断\n===属于严格相等，直接判断两者的类型是否相同，不同则返回fals\n如果相同再比较大小，不会进行任何隐式转换\n对于引用类型来说，比较的都是引用内存地址，所以===这种方式的比较，除非两者存储的内存地址相同才相等，反之false\n\n==涉及的类型转换规则\n两边的类型是否相同，相同的话就比较值的大小。\n判断是否是null和undefined，是的话就返回true。\n判断类型是否是String和Numner，是的话就把String类型转成Number，再比较。\n判断一方是否是Boolean，是的话就把Boolean转换成Number，再进行比较。\n如果其中一方是Object，且另一方为String、Number或者Symbol，会将Object转换成字符串，再进行比较。\n\n[]==![]\n首先将![]转为布尔值，[]-&gt;true，!true-&gt;false，false-&gt;0\n[]-&gt;0 故0==0，返回true。\n\n对象转原始类型是根据什么流程运行的？对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数，其逻辑如下：\n\n如果Symbol.toPrimitive()方法，优先调用再返回\n调用valueof()，如果转换为原始类型就返回\n调用toString()，如果转换为原始类型就返回\n如果都没有返回原始类型，会报错\n\n并非所有对象的隐式转换都会按照这个流程进行，Date对象会优先尝试toString方法来实现转换，非Date对象按照上述顺序。\n\n\n\n类型\nvalueOf\ntoString\n\n\n\nObject\n对象本身，这是默认情况\n返回’[object ObjectName]’，其中ObjectName是对象类型的名称\n\n\nString\n字符串值\n返回String对象的值\n\n\nNumber\n数字值\n返回数值的字符串表示、还可以返回指定进制表示的字符串\n\n\nBoolean\nBoolean值\n为true，返回’true’；为false，返回’false’\n\n\nArray\n数组本身\n将Array的每个元素转为字符串，并将他们依次连接起来，两个元素之间用英文逗号作为分隔符进行拼接\n\n\nDate\n存储的时间是从1970年1月1月午夜开始计的毫秒数UTC\n返回日期的文本表示\n\n\nFunction\n函数本身\n返回如下格式的字符串，其中functionname是一个函数的名称，此函数的toString()方法被调用：”function functionname(){[native code]}”\n\n\n例子({} + {})\n进行ToPrimitive转换，由于没有指定PreferredType类型，{}会使默认值为Number，进行ToPrimitive(input, Number)运算。\n执行valueOf方法，({}).valueOf(),返回的还是{}对象，不是原始值。\n继续执行toString方法，({}).toString(),返回”[object Object]”，是原始值。 故得到最终的结果，”[object Object]” + “[object Object]” = “[object Object] [object Object]”\n\n2 * {}首先*运算符只能对number类型进行运算，故第一步就是对{}进行ToNumber类型转换。\n\n由于{}是对象类型，故先进行原始类型转换，ToPrimitive(input, Number)运算。\n执行valueOf方法，({}).valueOf(),返回的还是{}对象，不是原始值。\n继续执行toString方法，({}).toString(),返回”[object Object]”，是原始值。\n转换为原始值后再进行ToNumber运算，”[object Object]”就转换为NaN。 故最终的结果为 2 * NaN =NAN\n\n参考：《可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用》\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"implicit-type","date":"2023-02-17T03:46:34.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"3aa48ecd1d5414b4b0af011d9171a628","title":"至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型","content":"我们先复习一下js的数据类型。\nJavaScript 的数据类型包括原始类型和对象类型：\n\n原始类型：Null、Undefined、Number、String、Boolean、Symbol、BigInt\n对象类型：Object\n\n我们习惯把对象称为引用类型，当然还有很多特殊的引用类型，比如 Function、Array、RegExp、Math、Date、Error、Set、Map、各种定型数组 TypedArray 等。\n\nJavaScript 中检测数据类型的方法有哪些你知道吗？\n\n\n\n\n\n\n\n\n\n\ntypeof\ninstanceof\nconstructor\nObject.prototype.toString.call()\n\ntypeoftypeof 'a' // 'string'\ntypeof 1   // 'number' \ntypeof true // 'boolean'\ntypeof undefined // 'undefined'\ntypeof Symbol('a') // 'symbol'\ntypeof 1n // 'bigint'\n\ntypeof null // 'object'\n\ntypeof function() {} // 'function'\ntypeof [] // 'object'\ntypeof {} // 'object'\ntypeof /a/ // 'object'\ntypeof new Date() // 'object'\ntypeof new Error() // 'object'\ntypeof new Map() // 'object'\ntypeof new Set() // 'object'\n\n两条结论：\n\ntypeof 可以判断除了 null 以外的原始类型。\ntypeof 只能判断对象类型中的 Function，其他判断不出来，都为 object。\n\ninstanceofconsole.log(1 instanceof Number) // false\nconsole.log(new Number(1) instanceof Number) // true\n\nconst arr = []\nconsole.log(arr instanceof Array) // true\nconsole.log(arr instanceof Object) // true\n\nconst Fn = function() {\n    this.name = '构造函数'\n}\nFn.prototype = Object.create(Array.prototype)\nlet a = new Fn()\nconsole.log(a instanceof Array) // true\n\n两条结论：\n\ninstanceof 可以准确判断对象(引用)类型，但是不能准确检测原始类型。\n由于我们可以随意修改原型的指向导致检测结果不准确，所以这种方法是不安全的。\n\n虽然 instanceof 不能检测原始类型，但是有一种方法可以让其用于检测原始类型。\nSymbol.hasInstance 允许我们自定义 instanceof 的行为。\nclass PrimitiveNumber {\n  static [Symbol.hasInstance] = x  => typeof x === 'number';\n}\n123 instanceof PrimitiveNumber; // true\n\nclass PrimitiveString {\n  static [Symbol.hasInstance] = x => typeof x === 'string';\n}\n'abc' instanceof PrimitiveString; // true\n\nclass PrimitiveBoolean {\n  static [Symbol.hasInstance] = x => typeof x === 'boolean';\n}\nfalse instanceof PrimitiveBoolean; // true\n\nclass PrimitiveSymbol {\n  static [Symbol.hasInstance] = x => typeof x === 'symbol';\n}\nSymbol.iterator instanceof PrimitiveSymbol; // true\n\nclass PrimitiveNull {\n  static [Symbol.hasInstance] = x => x === null;\n}\nnull instanceof PrimitiveNull; // true\n\nclass PrimitiveUndefined {\n  static [Symbol.hasInstance] = x => x === undefined;\n}\nundefined instanceof PrimitiveUndefined; // true\n\n代码来源:  有没有一种方法可以将instanceof用于原始JavaScript值？\nconstructor// 所以需要加上一个小括号，小括号运算符能够把数值转换为对象\n(1).constructor // ƒ Number() { [native code] }\n// 或者\n1..constructor // ƒ Number() { [native code] }\n\nconst a = '前端食堂'\nconsole.log(a.constructor) // ƒ String() { [native code] }\nconsole.log(a.constructor === String) // true\n\nconst b = 5\nconsole.log(b.constructor) // ƒ Number() { [native code] }\nconsole.log(b.constructor === Number) // true\n\nconst c = true\nconsole.log(c.constructor) // ƒ Boolean() { [native code] }\nconsole.log(c.constructor === Boolean) // true\n\nconst d = []\nconsole.log(d.constructor) // ƒ Array() { [native code] }\nconsole.log(d.constructor === Array) // true\n\nconst e = {}\nconsole.log(e.constructor) // ƒ Object() { [native code] }\nconsole.log(e.constructor === Object) // true\n\nconst f = () => 1\nconsole.log(f.constructor) // ƒ Function() { [native code] }\nconsole.log(f.constructor === Function) // true\n\nconst g = Symbol('1')\nconsole.log(g.constructor) // ƒ Symbol() { [native code] }\nconsole.log(g.constructor === Symbol) // true\n\nconst h = new Date()\nconsole.log(h.constructor) // ƒ Date() { [native code] }\nconsole.log(h.constructor === Date) // true\n\nconst i = 11n\nconsole.log(i.constructor) // ƒ BigInt() { [native code] }\nconsole.log(i.constructor === BigInt) // true\n\nconst j = /a/\nconsole.log(j.constructor) // ƒ RegExp() { [native code] }\nconsole.log(j.constructor === RegExp) // true\n\n\nString.prototype.constructor = 'aaa'\nconsole.log(a.constructor === String) // false\n\nconst k = null\nconsole.log(k.constructor) // Cannot read property 'constructor' of null\n\nconst l = undefined\nconsole.log(l.constructor) // Cannot read property 'constructor' of undefined\n\n两条结论：\n\n除了 null 和 undefined，constructor 可以正确检测出原始类型和对象(引用)类型。\n由于我们可以随意修改 constructor 导致检测结果不准确，所以这种方法是不安全的。\n\nObject.prototype.toString.call()toString() 方法返回一个表示该对象的字符串，我们可以改变它的 this 指向，将 this 指向要检测的值，即可返回当前检测值的信息。\nObject.prototype.toString({}) // '[object Object]'\n\nObject.prototype.toString.call({}) // '[object Object]'\nObject.prototype.toString.call('a') // '[object String]'\nObject.prototype.toString.call(1) // '[object Number]'\nObject.prototype.toString.call(true) // '[object Boolean]'\nObject.prototype.toString.call(null) // '[object Null]'\nObject.prototype.toString.call(undefined) // '[object Undefined]'\nObject.prototype.toString.call(Symbol('a')) // '[object Symbol]'\nObject.prototype.toString.call(11n) // '[object BigInt]'\nObject.prototype.toString.call(/a/) // '[object RegExp]'\nObject.prototype.toString.call(new Date()) // '[object Date]'\nObject.prototype.toString.call([0, 1, 2]) // '[object Array]'\nObject.prototype.toString.call(function() {}) // '[object Function]'\nObject.prototype.toString.call(new Error()) // '[object Error]'\nObject.prototype.toString.call(new Set()) // '[object Set]'\nObject.prototype.toString.call(new Map()) // '[object Map]'\n\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"judgment-type-method","date":"2023-02-16T08:53:16.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"448cccd8063bd5883f40c05f4e533fff","title":"null和undefined的区别","content":"undefinedundefined 的字面意思就是：未定义的值 。这个值的语义是，希望表示一个变量最原始的状态，而非人为操作的结果 。 这种原始状态会在以下 4 种场景中出现：\n声明一个变量，但是没有赋var foo;\nconsole.log(foo); // undefined\n\n访问 foo，返回了 undefined，表示这个变量自从声明了以后，就从来没有使用过，也没有定义过任何有效的值。\n访问对象上不存在的属性或者未定义的变量console.log(Object.foo); // undefined\nconsole.log(typeof demo); // undefined\n\n访问 Object 对象上的 foo 属性，返回 undefined ， 表示Object 上不存在或者没有定义名为 foo 的属性；对未声明的变量执行typeof操作符返回了undefined值。\n函数定义了形参，但没有传递实参//函数定义了形参 a\nfunction fn(a) {\n    console.log(a); // undefined\n}\nfn(); //未传递实参\n\n函数 fn 定义了形参 a，但 fn 被调用时没有传递参数，因此，fn 运行时的参数 a 就是一个原始的、未被赋值的变量。\n使用void对表达式求值void 0 ; // undefined\nvoid false; // undefined\nvoid []; // undefined\nvoid null; // undefined\nvoid function fn(){} ; // undefined\n\nnullnull 的字面意思是：空值 。这个值的语义是，希望表示一个对象被人为的重置为空对象，而非一个变量最原始的状态 。 在内存里的表示就是，栈中的变量没有指向堆中的内存对象。\n特殊的typeof nulllet data = null;\nconsole.log(typeof data); // \"object\"\n\n相同点值相同console.log( undefined == null )//true\n\n转换Boolean的都是falseconsole.log( Boolean(undefined) )//false\nconsole.log( Boolean(null) )//false\n\n不同点数据类型不同console.log( undefined === null )//false     \n\n转换为Number类型的值不同console.log( Number(undefined) )//NaN\nconsole.log( Number(null) )//0\n\n总结\nundefined相当于期房。 买了房,但是房子还没建出来。(未定义)\n\nnull相当于毛坯房。买了房,但是房子没住人,里面是空的。(空值)\n\n值是undefined的变量和未声明的变量，typeof运算结果都是“undefined”。运算符typeof运算null的类型时返回“object”。\n\n通过禁止使用特殊值undefined，可以有效地确保只在一种情况下typeof才会返回“undefined”：当变量未声明时。这样就可以区别null和undefined。\n\n\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"null-undefined-diff","date":"2023-02-16T04:30:00.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"54ea49642993052fe31a24e3d7d4f0a2","title":"基本类型对应的内置对象，以及他们之间的装箱拆箱操作","content":"内置对象内置对象\nObject是JS中所有对象的父对象\n数据封装类对象：Object Array Boolean Number String\n其他对象：Function Math Date RegExp Error特殊的基本包装类型String Number Booleanarguments只存在函数内部的一个类数组对象装箱和拆箱装箱把基本数据类型转换为对应的引用数据类型的操作称为装箱，可以分为隐式装箱和显式装箱。\n\n隐式装箱\n\n\n\n\n\n\n\n\n\n每当读取一个基本类型的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。             ——《JavaScript高级程序设计》\nlet a='sun'\nlet b=a.indexOf('s')\n//上述代码在后台实际的步骤为\nlet a=new String('sun')\nlet b=a.indexOf('s')\na=null\n\n上述代码中，a是基本数据类型，不是对象，不应该具有方法，JS内部进行了装箱操作，使得它能够调用方法。执行完相应的方法之后立即被销毁。\n拆箱将引用数据类型转换为基本数据类型，通过valueOf()和toString()实现。\nlet a=new String('sun')//object\nlet b=new Number(12)//object\na.valueOf() //'sun' string\na.valueOf() //12 number\nb.toString()//'sun'string\nb.toString()//'12' string\n\n参考：《基本类型对应的内置对象，以及他们之间的装箱拆箱操作》\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"built-object","date":"2023-02-16T02:12:23.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"205cdbee45bbacca672eccc7f03221f2","title":"JavaScript中的变量在内存中的具体存储形式","content":"栈内存和堆内存\n\n\n\n\n\n\n\n\nJavaScript中的变量分为基本类型和引用类型 基本类型是保存在栈内存中的简单数据段，它们的值都有固定的大小，保存在栈空间，通过按值访问\n引用类型是保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用\n\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"js-storageForm","date":"2023-02-15T09:27:34.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"aea670576bd859851504cb5f27ad22f5","title":"Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol","content":"前言在 Es6 中引入了一个新的基础数据类型:Symbol,对于其他基本数据类型(数字number,布尔boolean,null,undefined,字符串string)想必都比较熟悉,但是这个Symbol平时用得很少,甚至在实际开发中觉得没有什么卵用,能够涉及到的应用场景屈指可数.\n解决的问题在 Es5 的对象属性名中都是字符串,当一对象的属性名出现重复时,后者往往会覆盖前者.若使用Symbol就能够保证每个属性的名字都是独一无二的,相当于生成一个唯一的标识 ID,这样就从根本上防止属性名的冲突\nSymbol 应用场景应用场景 1-使用Symbol来作为对象属性名(key)const PERSON_NAME = Symbol();\nconst PERSON_AGE = Symbol();\nlet person = {\n    [PERSON_NAME]: \"随笔川迹\"\n}\nperson[PERSON_AGE] =  20;\nconsole.log(person[PERSON_NAME])  // 随笔川迹\nconsole.log(person[PERSON_AGE])   // 20\n\n在上面的示例代码中,使用Symbol创建了PERSON_NAME,PERSON_AGE两个Symbol类型,但是在实际开发中却带来了一些问题。Symbol类型实例化出的key是不能通过Object.keys(),for..in,for..of,来枚举的。ES6中提供了 Object.getOwnPropertySymbols()方法,可以获取指定对象的所有Symbol属性名,该方法会返回一个数组\n应用场景 2：使用 Symbol 定义类的私有属性/方法let size = Symbol('size');  // 声明定义了一个size变量,类型是Symbol(),类型描述内容是size\n\nclass Collection {          // class关键字定义了一个Collection类\n  constructor() {           // 构造器`constructor`函数\n    this[size] = 0;         // 在当前类上私有化了一个size属性\n  }\n\n  add(item) {              // Collection类下的一个方法\n    this[this[size]] = item;\n    this[size]++;\n  }\n\n  static sizeOf(instance) { // 静态属性\n    return instance[size];\n  }\n}\n\nlet x = new Collection(); // 实例化x对象\nCollection.sizeOf(x) // 0\n\nx.add('foo');       // 调用方法\nCollection.sizeOf(x) // 1\n\nObject.keys(x) // ['0']\nObject.getOwnPropertyNames(x) // ['0']\nObject.getOwnPropertySymbols(x) // [Symbol(size)]\n\n上面代码中，对象 x 的 size 属性是一个 Symbol 值，所以 Object.keys(x)、Object.getOwnPropertyNames(x)都无法获取它。这就造成了一种非私有的内部方法的效果\n应用场景 3-模块化机制结合Symbol与模块化机制,类的私有属性和方法完美实现,如下代码所示 在文件a.js中\nconst PASSWORD = Symbol();  // 定义一个PASSWORD变量,类型是Symbol\n\nclass Login() {      // class关键字声明一个Login类\n  constructor(username, password) {    // 构造器函数内初始化属性\n    this.username = username;\n    this[PASSWORD] = password;\n  }\n  checkPassword(pwd) {\n    return this[PASSWORD] === pwd;\n  }\n}\nexport default Login;\n\n在文件b.js中\nimport Login from './a'\n\nconst login = new Login('itclanCoder', '123456'); // 实例化一个login对象\n\nlogin.checkPassword('123456'); // true\nlogin.PASSWORD;  // 访问不到\nlogin[PASSWORD]; // 访问不到\nlogin['PASSWORD'] // 访问不到\n\n因为通过Symbol定义的PASSWORD常量定义在a.js模块中,外面的模块是获取不到这个Symbol的,在外部无法引用这个值,也无法改写,也不可能在在创建一个一模一样的Symbol出来\n因为Symbol是唯一的\n在a.js模块中,这个PASSWORD的Symbol类型只能在当前模块文件(a.js)中内部使用,所以使用它来定义的类属性是没有办法被模块外访问到的\n这样就达到了一个私有化的效果\n应用场景 4-使用Symbol来替代常量在使用React中,结合Redux做公共数据状态管理时,当想要改变组件中的某个状态时,reducer是一个纯函数,它会返回一个最新的状态给store,返回的结果是由action和state共同决定的\naction是一个对象,有具体的类型type值,如果你写过几行Redux的代码,就会常常看到,进行action的拆分,将事件动作的类型定义成常量\n\nconst CHANGE_INPUT_VALUE = 'CHANGE_INPUT_VALUE';  // 监听input框输入值的常量\nconst ADD_INPUT_CONTENT = 'ADD_INPUT_CONTENT';    // 添加列表\nconst DELETE_LIST = 'DELETE_LIST';                // 删除列表\n\nfunction reducer(state, action) {\n    const newState =  JSON.parse(JSON.stringify(state));\n  switch(action.type) {\n    case CHANGE_INPUT_VALUE:\n      // ...\n    case ADD_INPUT_CONTENT:\n      // ...\n    case DELETE_LIST;\n      // ...\n    default:\n      return state;\n    }\n}\n\n以上代码在Redux中很常见,将action对象中的type值,给抽离出来,定义一个常量存储,来代表一种业务逻辑,通常希望这些常量是唯一的,在Redux中定义成常量,是为了便于调试查错\n常常因为取type值时,非常苦恼.\n现在有了Symbol,改写一下,就可以这样\nconst CHANGE_INPUT_VALUE = Symbol()\nconst ADD_INPUT_CONTENT = Symbol();\nconst DELETE_LIST = Symbol()\n\nfunction reducer(state, action) {\n    const newState =  JSON.parse(JSON.stringify(state));\n    switch(action.type) {\n    case CHANGE_INPUT_VALUE:\n      // ...\n    case ADD_INPUT_CONTENT:\n      // ...\n    case DELETE_LIST;\n      // ...\n    default:\n      return state;\n    }\n}\n\n通过Symbol定义字符串常量,就保证了三个常量的值唯一性\n划重点\n\n常量使用Symbol值最大的好处,就是其他任何值都不可能有相同的值了,可以保证常量的唯一性,因此,可以保证上面的switch语句按照你设计的方式条件去工作\n当Symbol值作为属性名时,该属性是公开属性,不是私有属性\n\n应用场景 5-注册和获取全局的 Symbol在浏览器窗口(window)中,使用Symbol()函数来定义生成的Symbol实例是唯一的\n但是若应用涉及到多个window,最常见的就是在各个页面窗口中嵌入iframe了,并在各个iframe页面中取到来自同一份公共的数据源\n也就是在各个window中使用的某些Symbol希望是同一个,那么这个时候,使用Symbol()就不行不通了\n因为用它在不同window中创建的Symbol实例总是唯一的，而我们需要的是在所有这些window环境下保持一个共享的Symbol值。\n在这种情况下，我们就需要使用另一个 API 来创建或获取Symbol，那就是Symbol.for()，它可以注册或获取一个window间全局的Symbol实例，它是Symbol的一个静态方法\n这个在前面已经提到过一次,这个还是有那么一点点用处,所以在提一嘴的\n如下示例代码所示\nlet gs1 = Symbol.for('global_symbol_1')  //注册一个全局Symbol\nlet gs2 = Symbol.for('global_symbol_1')  //获取全局Symbol\n\nconsole.log(gs1 === gs2 ) // true\n\n经过Symbol.for()实例化出来的Symbol字符串类型,只要描述的内容相同,那么不光是在当前window中是唯一的,在其他全局范围内的window也是唯一的,并且相同\n该特性,若是创建跨文件可用的symbol，甚至跨域（每个window都有它自己的全局作用域） , 可以使用 Symbol.for()取到相同的值\n也就是说,使用了Symbol.for()在全局范围内,Symbol类型值可以共享\n注意事项\nSymbol 值不能与其他类型的值进行运算-会报错\n\nlet symItclan = Symbol('itclan');\n\nconsole.log(\"主站\" + symItclan)\nconsole.log(`主站 ${symItclan}`) // Uncaught TypeError: Cannot convert a Symbol value to a string\n\n\nSymbol可以显示转为字符串\n\nlet SyItclanCoder = Symbol('https://coder.itclan.cn');\n\nconsole.log(String(SyItclanCoder)) // Symbol(https://coder.itclan.cn)\nconsole.log(SyItclanCoder.toString()) // Symbol(https://coder.itclan.cn)\n\n\nSymbol值可以转为布尔值,但是不能转为数值\n\nlet sym = Symbol();\nconsole.log(Boolean(sym)) // true\nconsole.log(!sym)  // false\n\nif (sym) {\n  // ...\n}\n\nNumber(sym) // TypeError  Cannot convert a Symbol value to a number\nsym + 2 // TypeError\n\n由上面的错误提示可以看出,Symbol不能转换为数字,无法做相应的运算\n\nSymbol函数不能使用new命令\n\nSymbol函数前不能使用new命令,否则就会报错,Symbol是一个原始类型的值,不是对象,它是类似字符串的数据类型\n\nSymbol值作为对象属性名时，不能用点运算符\n\n当Symbol值作为对象的属性名时,访问它时,不能用点运算符\nconst username = Symbol();\nconst person = {};\nperson.username = '随笔川迹';\nperson[username]; // undefined\nperson['username']; // 随笔川迹\n\n第 4 行代码值为undefined,因为点运算符后面总是字符串,所以不会读取username作为标识符名所指代的那个值\n导致person对象的属性名实际上是一个字符串,而不是一个Symbol值\n由此可见:在对象内部,使用Symbol类型定义属性名时,Symbol值必须放在中括号之中\nlet s = Symbol();\nlet obj = {\n  [s]: function(arg) {\n    return arg;\n  }\n}\nobj[s](\"itclanCoder\")\n\n在上面的代码中,如果变量s不放在中括号中,该属性的键名就是字符串s,而不是定义Symbol类型值\n参考：《理解 Es6 中的 Symbol 类型》\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"symbol-devAndapp","date":"2023-02-15T09:27:34.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"54ad94266d02aab420ff03426bccde3c","title":"JavaScript对象的底层数据结构是什么","content":"上一篇文章归纳了javascript的数据类型，归根到底数据类型就分为两类，一种是基本类型，一种是引用类型。文章链接《JavaScript规定了几种语言类型》\n基本类型\n内容：String、Number、Boolean、Undefined、Null、Symbol、BigInt\n特点：值不可变，无属性无方法，保存在栈内存中、值比较。\n\n引用类型\n内容：引用类型统称为Object类型。细分的话有：Object、Array、Date、RegExp、Function  等特点：引用类型的值同时保存在栈内存和堆内存中的对象。栈区内存保存变量标识符，堆内存存储对象的地址\n\n什么是数据结构？数据结构是一种组织、管理和存储数据的形式，这种形式方便数据访问和修改。\nJavaScript使用的是 堆(Heap) 和 栈( Stack)堆\n是堆内存的简称，堆是动态分配内存，内存大小不固定，也不会自动释放\n\n队列优先,先进先出，方便存储和开辟内存空间。\n\n\n栈\n栈内存的简称，自动分配相对固定大小的内存空间，并由系统自动释放。\n基本类型存储在栈内存的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间\n线性结构，后进先出，便于管理。\n\n数据结构相关 — 浅拷贝、深拷贝浅拷贝创建新的数据，这个数据有着原始数据属性值的一份精确拷贝\n浅拷贝是拷贝一层，深层次的引用类型则共享内存地址\n\n\n\n\n\n\n\n\n\n浅拷贝实现方法：\n\nObject.assign\nslice()\nconcat()\n拓展运算符 …\n\nObject.assignlet obj = {\n    age: 18,\n    nature: ['smart', 'good'],\n    names: {\n        name1: 'fx',\n        name2: 'xka'\n    },\n    love: function () {\n        console.log('fx is a great girl')\n    }\n}\nvar newObj = Object.assign({}, obj);\n\nslice()const fxArr = [\"One\", \"Two\", \"Three\"]\nconst fxArrs = fxArr.slice(0)\nfxArrs[1] = \"love\";\nconsole.log(fxArr) // [\"One\", \"Two\", \"Three\"]\nconsole.log(fxArrs) // [\"One\", \"love\", \"Three\"]\n\nconcat()const fxArr = [\"One\", \"Two\", \"Three\"]\nconst fxArrs = fxArr.concat()\nfxArrs[1] = \"love\";\nconsole.log(fxArr) // [\"One\", \"Two\", \"Three\"]\nconsole.log(fxArrs) // [\"One\", \"love\", \"Three\"]\n\n拓展运算符 …onst fxArr = [\"One\", \"Two\", \"Three\"]\nconst fxArrs = [...fxArr]\nfxArrs[1] = \"love\";\nconsole.log(fxArr) // [\"One\", \"Two\", \"Three\"]\nconsole.log(fxArrs) // [\"One\", \"love\", \"Three\"]\n\n深拷贝深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性\n\n\n\n\n\n\n\n\n\n  实现方法：\n\n_.cloneDeep()\njQuery.extend()\nJSON.stringify()\n手写循环递归\n\n_.cloneDeep()const _ = require('lodash');\nconst obj1 = {\n    a: 1,\n    b: { f: { g: 1 } },\n    c: [1, 2, 3]\n};\nconst obj2 = _.cloneDeep(obj1);\nconsole.log(obj1.b.f === obj2.b.f);// false\n\njQuery.extend()const $ = require('jquery');\nconst obj1 = {\n    a: 1,\n    b: { f: { g: 1 } },\n    c: [1, 2, 3]\n};\nconst obj2 = $.extend(true, {}, obj1);\nconsole.log(obj1.b.f === obj2.b.f); // false\n\nJSON.stringify()const obj2=JSON.parse(JSON.stringify(obj1));\n// 但是这种方式存在弊端，会忽略undefined、symbol和函数\n\n手写循环递归function deepClone(obj, hash = new WeakMap()) {\n  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作\n  if (obj instanceof Date) return new Date(obj);\n  if (obj instanceof RegExp) return new RegExp(obj);\n  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝\n  if (typeof obj !== \"object\") return obj;\n  // 是对象的话就要进行深拷贝\n  if (hash.get(obj)) return hash.get(obj);\n  let cloneObj = new obj.constructor();\n  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身\n  hash.set(obj, cloneObj);\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      // 实现一个递归拷贝\n      cloneObj[key] = deepClone(obj[key], hash);\n    }\n  }\n  return cloneObj;\n}\n\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"js-data-structure","date":"2023-02-15T05:21:00.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"be69bcf460f3a988c3f4f8fd1e3998bb","title":"JavaScript规定了几种语言类型","content":"前言JavaScript是什么？这里引用百度百科的说法\n\n\n\n\n\n\n\n\n\nJavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式、声明式、函数式编程范式。\n语言类型ps：检测数据类型的操作符typeof\nBoolean：布尔值，true或者false，表示逻辑上的真和假【基本类型】let a = true;\ntypeof a;    // 'boolean'\n\nnumber：数字【基本类型】// 数字类型，最大2^53 - 1，即 9007199254740991，大于这个值可能会失去精度\nlet a = 9007199254740991;\nlet b = 90071992547409911;\nlet c = NaN;    // NaN是特殊的number类型\nconsole.log(a);    // 9007199254740991\nconsole.log(b);    // 90071992547409900 失去精度\ntypeof a;    // 'number'\ntypeof c;    // 'number'\n\nstring：字符串【基本类型】// 字符串类型\nlet a = 'aaa';\ntypeof a;    // 'string'\n\nundefined：未定义【基本类型】// 声明了但未定义值\nlet a;\nconsole.log(a); // undefined\ntypeof(a); // 'undefined'\n\nnull：空值【基本类型】// 空值\nlet a = null;\ntypeof a;    // object\n\nps: 虽然typeof null为object，但这只是JavaScript 存在的一个悠久 Bug，不代表null就是引用数据类型，并且null本身也不是对象\nsymbol： 独一无二的值【基本类型】// 独一无二的值\nlet a = Symbol();\ntypeof a;    // symbol\n\nps: ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。Symbol类型实例化出的key是不能通过Object.keys(),for..in,for..of,来枚举的\nBigInt: 大整数【基本类型】// 要创建 a `BigInt`，请将 n 附加到整数末尾或调用 BigInt()\nlet a = 999n;\nlet b = BigInt(999);\ntypeof a;    // 'bigint'\ntypeof b;    // 'bigint'\n\nps: BigInt目前已经进入Stage 4阶段 下一个版本将会作为新特性出现在ECMAScript 。BigInt是JavaScript中一种可以用来表示任意精度整数的基本数据类型。使用BigInt可以安全的存储和操作任意大小的整数而不受Number类型的安全值范围的限制\nobject：对象，包含array,date等【引用类型】let a = [];\nlet b = {};\nlet c = new Date();\ntypeof a;    // 'object'\ntypeof b;    // 'object'\ntypeof c;    // 'object'\n\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"js-specThe-langType","date":"2023-02-15T03:34:00.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"4298a08c1e0e68f5aeb283438517f755","title":"nginx配置","content":"服务器 nginx 配置一般目录地址：\n/etc/nginx\n\nnginx.conf 配置示例# For more information on configuration, see:\n#   * Official English Documentation: http://nginx.org/en/docs/\n#   * Official Russian Documentation: http://nginx.org/ru/docs/\n\nuser www-data;\nworker_processes auto;\nworker_rlimit_nofile 65535;\nerror_log /var/log/nginx/error.log;\npid /run/nginx.pid;\n\n# Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.\n# include /usr/share/nginx/modules/*.conf;\n\nevents {\n    worker_connections 1024;\n}\n\nhttp {\n\n    include             /etc/nginx/mime.types;\n    default_type        application/octet-stream;\n\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    access_log  /var/log/nginx/access.log  main;\n\n    sendfile            on;\n    #tcp_nopush          on;\n    tcp_nodelay         on;\n    keepalive_timeout   100;\n    types_hash_max_size 2048;\n    client_max_body_size 100m;\n    underscores_in_headers on;\n\n    server_names_hash_max_size 1024;\n    server_names_hash_bucket_size 64;\n\n    # Load modular configuration files from the /etc/nginx/conf.d directory.\n    # See http://nginx.org/en/docs/ngx_core_module.html#include\n    # for more information.\n    include /etc/nginx/conf.d/*.conf;\n    include /etc/nginx/sites-enabled/*;\n\n# Settings for a TLS enabled server.\n#\n#    server {\n#        listen       443 ssl http2 default_server;\n#        listen       [::]:443 ssl http2 default_server;\n#        server_name  _;\n#        root         /usr/share/nginx/html;\n#\n#        ssl_certificate \"/etc/pki/nginx/server.crt\";\n#        ssl_certificate_key \"/etc/pki/nginx/private/server.key\";\n#        ssl_session_cache shared:SSL:1m;\n#        ssl_session_timeout  10m;\n#        ssl_ciphers HIGH:!aNULL:!MD5;\n#        ssl_prefer_server_ciphers on;\n#\n#        # Load configuration files for the default server block.\n#        include /etc/nginx/default.d/*.conf;\n#\n#        location / {\n#        }\n#\n#        error_page 404 /404.html;\n#        location = /404.html {\n#        }\n#\n#        error_page 500 502 503 504 /50x.html;\n#        location = /50x.html {\n#        }\n#    }\n\n}\n\nconf.d 文件夹配置示例# 文件名起 xxx.conf\n# 配置示例\n\n# jenkins.conf 示例\nserver {\n    listen 80;\n    server_name jenkins.xxx.xxx.xxx;\n\n    access_log /etc/nginx/logs/jenkins.access.log main;\n    error_log /etc/nginx/logs/jenkins.error.log warn;\n\n    location / {\n        proxy_pass http://localhost:8080;\n    }\n}\n\n# 站点配置示例\n# xxx.conf\nserver {\n    listen 80;\n    server_name ~^([a-zA-Z0-9-]+)\\.pda-dev\\.xxx(域名配置)\\.xxx(域名配置)\\.xxx(域名配置)$;\n    set $platform $1;\n\n    charset utf-8;\n    access_log /etc/nginx/logs/pda.admin.dev.access.log main;\n    error_log /etc/nginx/logs/pda.admin.dev.error.log error;\n\n    location @rewrites {\n        rewrite ^.*$ /index.html last;\n    }\n\n    location /api {\n        proxy_pass http://api.pda-dev-admin.xxx(域名配置);\n    }\n\n    location / {\n        root /mnt/data/www/frontend_deploy_workspace/dev/pda/$platform;\n        try_files $uri $uri/ @rewrites;\n        index index.html;\n    }\n}\n\n","slug":"xu9t5l","date":"2021-12-19T09:08:00.000Z","categories_index":"nginx","tags_index":"nginx","author_index":"手可摘星陈"},{"id":"bddf5d070a36a0f1beeaeeaa433a90bd","title":"ubuntu 部署jenkins","content":"服务器部署 jenkinsjenkinsci/blueocean 安装docker pull jenkinsci/blueocean\ndoker 部署 jenkinsdocker run -d -u root --name jenkins -p 8080:8080 -p 50000:50000 -v /data/jenkins_home:/var/jenkins_home jenkinsci/blueocean:lts\n\ndocker run -d -u root --name jenkins -p 8080:8080 -p 50000:50000 -v /workspace/data/jenkins:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v /etc/timezone:/etc/timezone -v /etc/localtime:/etc/localtime jenkinsci/blueocean:1.25.1\n\n查看 Jenkins 启动情况# 查看启动项\ndocker ps\n# 查看全部\ndocker ps -a\n\n遇到的问题Jenkins 容器 docker run 之后状态 Exited# 查看docker日志 ：\ndocker logs jenkins\n发现是目前权限问题\n因为/data/jenkins_home 目录是root权限\n\n解决方法chown -R 1000 /data/jenkins_home //用户组改变\n\nJenkins 首次登录需要密码// 进入容器\ndocker exec -it de20d10b6046（容器id） bash\ncat /var/jenkins_home/secrets/initialAdminPassword //查看密码\n\njenkins 部署项目添加节点进入容器 创建 ssh 证书 连接寄主机# 生成证书\nssh-keygen -t rsa -C \"kingpi@163.com\" -f ~/.ssh/host-rsa\n# 进入.ssh\ncd ~/.ssh\n\n添加 configHost 172.17.0.1（寄主机docker ip）\n  HostName 172.17.0.1\n  User root\n  PreferredAuthentications publickey\n  IdentityFile ~/.ssh/host-rsa\n\n寄主机进入 ~/.sshcd ~/.ssh\n\n进入文件 authorizedkeysvi authorized_keys\n# 输入 上面创建的 连接寄主机 ssh证书公钥\n\njenkins 添加 节点\njenkins 容器内创建连接 github 证书ssh-keygen -t rsa -C \"kingpi@163.com\" -f ~/.ssh/github.com\n# config 添加host\n\njenkins 添加凭证 如上面 图连接远程服务器jenkins 容器内创建证书ssh-keygen -t rsa -C \"kingpi@163.com\" -m PEM -P \"\" -f ~/.ssh/yooleap.net\n# config 添加host\n\njenkins 系统配置配置服务器信息 添加上私钥\n遇到的问题# 连接服务器测试报错\njenkins.plugins.publish_over.BapPublisherException: Failed to add SSH key. Message [invalid privatekey: [B@59df330d]_\n\n# 解决方法\nssh openSSH 版本过高 改用RSA\nssh-keygen -t rsa -C \"kingpi@163.com\" -m PEM -P \"\" -f ~/.ssh/yooleap.net\n\n","slug":"dhm7uz","date":"2021-12-10T03:10:00.000Z","categories_index":"jenkins部署","tags_index":"jenkins,ubuntu","author_index":"手可摘星陈"},{"id":"0e3cfafab513b2ddf7256c9eacf77c51","title":"element-plus修改主题色","content":"先安装 vite 构建工具# 先安装 vite 构建工具\nnpm install -g create-vite-app\n\n创建项目：# 下面两个命令都可以\ncreate-vite-app vue3-demo\ncva vue3-demo\n\n按照官网修改主题色官网我选择的是通过 scss 修改主题色例子参照：element-plus-vite-starter\n创建 index.scss 文件# ./styles/element/index.scss\n$--colors: (\n  \"primary\": (\n    \"base\": #ee4444,\n  ),\n  \"success\": (\n    \"base\": #21ba45,\n  ),\n  \"warning\": (\n    \"base\": #f2711c,\n  ),\n  \"danger\": (\n    \"base\": #db2828,\n  ),\n  \"error\": (\n    \"base\": #db2828,\n  ),\n  \"info\": (\n    \"base\": #42b8dd,\n  ),\n);\n\n@forward \"element-plus/theme-chalk/src/common/var.scss\" with\n  (\n    // do not use same name, it will override.\n    $colors: $--colors,\n    $button-padding-horizontal: (\"default\": 50px)\n  );\n\nvue.config.ts 代码如下import path from \"path\";\nimport { defineConfig } from \"vite\";\nimport vue from \"@vitejs/plugin-vue\";\n\nimport Components from \"unplugin-vue-components/vite\";\nimport { ElementPlusResolver } from \"unplugin-vue-components/resolvers\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  resolve: {\n    alias: {\n      \"~/\": `${path.resolve(__dirname, \"src\")}/`,\n    },\n  },\n  css: {\n    preprocessorOptions: {\n      scss: {\n        additionalData: `@use \"~/styles/element/index.scss\" as *;`,\n      },\n    },\n  },\n  plugins: [\n    vue(),\n    Components({\n      resolvers: [\n        ElementPlusResolver({\n          importStyle: \"sass\",\n        }),\n      ],\n    }),\n  ],\n});\n\n","slug":"ual5ig","date":"2021-11-01T03:21:00.000Z","categories_index":"Vue","tags_index":"Vue,Vue3,element-plus","author_index":"手可摘星陈"},{"id":"f75c33a49b8a527fa8975e81f9d8e4eb","title":"vue3 使用 百度地图","content":"Vue3 使用 百度地图的报错的问题vue3 项目中使用百度地图总是报错 BMap is not defined.\npublic/index.html 中加入&lt;script\n  type=\"text/javascript\"\n  src=\"http://api.map.baidu.com/api?v=3.0&amp;ak=你的ak\"\n>&lt;/script>\n\n.eslintrc.js 中加入module.exports = {\n  ...,\n  globals: {\n     BMap: true\n  }\n}\n\nvue.config.js 中加入module.exports = {\n   ...,\n   configureWebpack: {\n      externals: {\n        \"BMap\": \"BMap\"\n      }\n   }\n}\n\n重新运行项目在组件中添加 import BMap from ‘BMap’\nonMounted(() => {\n  var map = new BMap.Map(\"map\");\n  var point = new BMap.Point(116.404, 39.915);\n  map.centerAndZoom(point, 5);\n  map.addControl(new BMap.NavigationControl());\n});\n\n如果为 TSimport BMap from ‘BMap’报错\n解决：在 src 下新建文件 shims-BMap.d.ts 内容为declare module 'BMap' {\n  const BMap: any\n  export default BMap\n}\n\n参考取自：vue3 使用百度地图\n","slug":"evr2ba","date":"2021-08-19T03:19:10.000Z","categories_index":"问题记录","tags_index":"vue3,vue","author_index":"手可摘星陈"},{"id":"73b906900ddb1992b894f7b40254513c","title":"swiper在loop模式下获取当前下标","content":"前言\n\n\n\n\n\n\n\n\n项目需要根据轮播来改变对应背景和文字，所以需要获取当前轮播的下标。轮播是 水平卡片式轮播，教程在前文 vue 水平卡片式轮播\nloop 下 swiper6 获取当前轮播下标\n\n\n\n\n\n\n\n\n获取下标方式： this.activeIndex % length// 当前下标除以数组长度取余\n代码示例：new Swiper(\".swiper3\", {\n  direction: \"horizontal\", //滑动方向，可设置水平(horizontal)或垂直(vertical)。\n  loop: true, // 设置为true 则开启loop模式\n  slidesPerView: \"auto\", // 设置slider容器能够同时显示的slides数量(carousel模式)。类型：number or auto\n  centeredSlides: true, // 设定为true时，active slide会居中，而不是默认状态下的居左。\n  spaceBetween: 20, // 在slide之间设置距离（单位px）。\n  autoplay: {\n    // 设置为false，用户操作swiper之后自动切换不会停止\n    disableOnInteraction: false,\n  },\n  navigation: {\n    nextEl: \".swiper-button-next\",\n    prevEl: \".swiper-button-prev\",\n  },\n  on: {\n    // eslint-disable-next-line space-before-function-paren\n    slideChangeTransitionStart: function () {\n      state.swiperIndex = this.activeIndex % state.swiperList.length;\n    },\n  },\n});\n\n","slug":"wv1yf2","date":"2021-08-18T07:40:00.000Z","categories_index":"问题记录","tags_index":"vue3,swiper6","author_index":"手可摘星陈"},{"id":"bba42ffdd017886e6e2fb7bd45b831c6","title":"vue相关问题合集","content":"vue2 和 vue3 router 更改 hash 模式前言项目部署到线上之后，发现刷新页面之后会 404，所以我们需要将 router 的模式从 history 换成 hash\n\n\n\n\n\n\n\n\n\n项目采用了 vue3+ts 框架\nvue2historyconst router = new VueRouter({\n  mode: 'history',\n  routes: [...]\n})\n\nhashconst router = new VueRouter({\n  mode: 'hash',  //或者把这句话注释，默认就是hash\n  routes: [...]\n})\n\nvue3history// 引入 createWebHistory\nimport { createRouter, createWebHistory } from \"vue-router\";\nconst router = createRouter({\n  history: createWebHistory(process.env.BASE_URL),\n  routes,\n});\n\nhash// 引入 createWebHashHistory\nimport { createRouter, createWebHashHistory } from \"vue-router\";\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes,\n});\n\nvue 遮罩层禁止滚动\n\n\n\n\n\n\n\n\n在遮罩层 div 添加 @touchmove.prevent @mousewheel.prevent\n\n\n\n\n\n\n\n\n\npc 端禁止遮罩层滚动\n//停止页面滚动\nstopMove(){\n    let m =function(e){e.preventDefault();};\n    document.body.style.overflow='hidden';\n    document.addEventListener(\"touchmove\", m, false);//禁止页面滑动\n},\n\n//开启页面滚动\nMove(){\n    let m =function(e){e.preventDefault();};\n    document.body.style.overflow='';//出现滚动条\n    document.removeEventListener(\"touchmove\", m, true);\n}\n\nSyntax Error: Error: Node Sass does not yet support your current environment: OS X 64-bit with Unsupported runtime (102)\n\n\n\n\n\n\n\n\n遇到问题：\n\nSyntax Error: Error: Node Sass does not yet support your current environment: OS X 64-bit with Unsupported runtime (102)\nNode Sass 7.0.0 版本与^4.0.0 不兼容\n\n// 解决方法\n使用sass 卸载node-sass\n1. 使用npm\n // 卸载\n npm uninstall node-sass\n // 安装sass\n npm i -D sass\n2. 使用yarn\n // 卸载\n yarn remove node-sass\n // 安装sass\n yarn add -D sass\n\n在使用 yarn 安装依赖包时报错，提示信息：error An unexpected error occurred: “https://registry.yarnpkg.com/killable/-/killable-1.0.0.tgz: connect ETIMEDOUT 104.16.19.35:443”解决方案：\n\n\n\n\n\n\n\n\n运行命令，把资源地址设置成 npm 淘宝源\nnpm config set registry https://registry.npm.taobao.org\nnpm config set disturl https://npm.taobao.org/dist\n\n","slug":"hhwazy","date":"2021-08-18T03:42:00.000Z","categories_index":"问题记录","tags_index":"vue3,vue","author_index":"手可摘星陈"},{"id":"222dc9cc365798f93f2c01d1c0b50ede","title":"Hexo 叨叨点啥图床改为SM.MS","content":"简介\n\n\n\n\n\n\n\n\n按照叨叨点啥教程设置使用 7bu 图床，我上传图片的时候很多图片上传不成功所以我就自己修改图床\n本文中使用 SM.MS 图床\n叨叨点啥教程地址叨叨点啥教程\n教程先注册 SM.MS 账号修改 ios 图床地址\n\n\n\n\n\n\n\n\n把 7bu 图床的地址换成 SM.MS 的上传地址\n修改请求头和参数\n\n\n\n\n\n\n\n\n请求头添加 Authorization 后面文本粘贴你的 SM.MS token 值\n请求体改为 smfile改如下图圈起来的地方\n修改匹配正则表达式\n\n\n\n\n\n\n\n\n原匹配参数 (?&lt;=”url”:”).*(?=”/},)\n改为 (?&lt;=”url”:”).+?(?=”,”)如下图所示\n修改完成 可以上传图片了","slug":"xxwo2p","date":"2021-08-09T10:36:44.000Z","categories_index":"Hexo","tags_index":"Hexo","author_index":"手可摘星陈"},{"id":"cebfd5726c785c1656c2de1493058390","title":"vue水平卡片式轮播","content":"vue 水平卡片式轮播基于 vue3 + ts 开发的\n\n项目需要完成如上图的轮播，这是水平卡片式轮播。我的项目是基于 vue3+ts 开发的，我使用 swiper 来完成该轮播开发。具体代码如下文\n\n首先安装 swipernpm install swiper --save\n// or\nyarn add swiper\n\nhtml 代码&lt;template>\n  &lt;div>\n    &lt;div class=\"examples\">\n      &lt;div class=\"bannerBox\">\n        &lt;div class=\"swiper-container swiper3\">\n          &lt;div class=\"swiper-wrapper\">\n            &lt;div\n              class=\"swiper-slide\"\n              v-for=\"(item, index) in banner\"\n              :key=\"index\"\n            >\n              &lt;img :src=\"item.picture_path\" alt=\"\" />\n            &lt;/div>\n          &lt;/div>\n          &lt;div class=\"swiper-pagination\">&lt;/div>\n          &lt;div class=\"swiper-button-prev swiper-button-white\">&lt;/div>\n          &lt;div class=\"swiper-button-next swiper-button-white\">&lt;/div>\n        &lt;/div>\n      &lt;/div>\n    &lt;/div>\n  &lt;/div>\n&lt;/template>\n\njavascript 代码&lt;script>\n// 有部分没用到你们可以不引用\nimport Swiper, { Autoplay, EffectCoverflow, EffectCube, Pagination, Navigation } from 'swiper';\nSwiper.use([Autoplay, EffectCoverflow, EffectCube, Pagination, Navigation]);\nimport 'swiper/swiper.min.css';\nimport 'swiper/components/navigation/navigation.scss';\nimport 'swiper/components/pagination/pagination.scss';\n\nexport default {\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  data() {\n    return {\n      bannerIndex: 0,\n      banner: [\n        {\n          picture_path: require('../../assets/home/home_bg.png')\n        },\n        {\n          picture_path: require('../../assets/home/lunbo.png')\n        },\n        {\n          picture_path: require('../../assets/home/home_bg2.png')\n        }\n      ]\n    };\n  },\n  mounted() {\n    let that = this;\n    let mySwiper = new Swiper('.swiper3', {\n      direction: 'horizontal', //滑动方向，可设置水平(horizontal)或垂直(vertical)。\n      loop: true, // 设置为true 则开启loop模式\n      autoplay: true, // 自动切换时间\n      speed: 500, // 切换速度\n      slidesPerView: 'auto', // 设置slider容器能够同时显示的slides数量(carousel模式)。类型：number or auto\n      centeredSlides: true, // 设定为true时，active slide会居中，而不是默认状态下的居左。\n      spaceBetween: 10, // 在slide之间设置距离（单位px）。\n      loopAdditionaSlider: 0, // loop模式下会在slides前后复制若干个slide,，前后复制的个数不会大于原总个数。\n      navigation: {\n        nextEl: '.swiper-button-next',\n        prevEl: '.swiper-button-prev',\n      },\n      pagination: {\n        el: '.swiper-pagination',\n        type: 'fraction'\n      },\n    });\n  },\n};\n&lt;/script>\n\ncss 代码&lt;style lang=\"scss\" scoped>\n.examples{\n  padding: 100px;\n}\n.bannerTxt{\n  height: 60px;\n  line-height: 60px;\n  text-align: center;\n  color: #666666;\n  font-size: 15px;\n}\n.bannerIndex{\n  line-height: 40px;\n  text-align: center;\n  color: #666666;\n  font-size: 15px;\n  text-align: center;\n  span{\n    color: #b5654d;\n  }\n}\n.bannerBox{\n  position: relative;\n  height: 490px;\n}\n.swiper3 {\n  width: 100%;\n  height: 100%;\n}\n.swiper3 .swiper-wrapper .swiper-slide {\n  width: 940px !important;\n  overflow: hidden;\n  display: flex;\n  align-items: center;\n  margin-right: 20px !important;\n}\n.swiper3 .swiper-wrapper .swiper-slide img {\n  width: 100%;\n  height: 490px;\n  border-radius: 5px;\n}\n.swiper3 .swiper-wrapper .swiper-slide-prev,.swiper3 .swiper-wrapper .swiper-slide-next{\n  height: 490px !important;\n  border-radius: 5px;\n  background: #000;\n  // margin-top: 20px;\n}\n.swiper3 .swiper-wrapper .swiper-slide-prev img,.swiper3 .swiper-wrapper .swiper-slide-next img{\n  opacity:0.6; filter: alpha(opacity=60);\n  width: 100%;\n  height: 100%;\n}\n.swiper3 .swiper-pagination {\n  color: #fff;\n}\n&lt;/style>\n\n","slug":"gwcyel","date":"2021-07-20T06:36:55.000Z","categories_index":"Vue","tags_index":"Vue,swiper6","author_index":"手可摘星陈"}]