[{"id":"9c0e46ac234b95fe1f1741ca7e4e7d0c","title":"理解原型设计模式以及JavaScript中的原型规则","content":"原型规则原型规则所有的引用类型（数组、对象、函数），都具有对象特征，即可自由扩展属性；\nvar arr = []; arr.a =1;\n\n所有的引用类型都有对象的特性，即可自由扩展\n所有的引用类型都有一个_proto_属性（隐式原型），属性的值是一个普通对象\n所有函数，都具有一个prototype（显示原型），属性值也是一个普通原型\n所有的引用类型（数组、对象、函数），其隐式原型指向其构造函数的显式原型；（obj.proto === Object.prototype）\n当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么回去它的_proto_（即它的构造函数的prototype）中去寻找原型对象prototype 在js中，函数对象其中一个属性：原型对象prototype。普通对象没有prototype属性，但有_proto_属性。 原型的作用就是给这个类的每一个对象都添加一个统一的方法，在原型中定义的方法和属性都是被所以实例对象所共享。var person = function(name)&#123;\n    this.name = name\n&#125;;\nperson.prototype.getName=function()&#123;//通过person.prototype设置函数对象属性\n    return this.name; \n&#125;\nvar crazy= new person(‘crazyLee’);\ncrazy.getName(); //crazyLee//crazy继承上属性\n原型链当试图得到一个对象f的某个属性时，如果这个对象本身没有这个属性，那么会去它的_proto_（即它的构造函数的prototype）obj._proto_中去寻找；当obj._proto也没有时，便会在obj._proto.proto（即obj的构造函数的prototype的构造函数的prototype）中寻找设计模式工厂模式在函数内创建一个对象，给对象赋予属性及方法再将对象返回function Person() &#123;\n\tvar People = new Object();\n\tPeople.name = 'CrazyLee';\n\tPeople.age = '25';\n\tPeople.sex = function()&#123;\n\t\treturn 'boy';\n\t&#125;;\n\treturn People;\n&#125;\n\nvar a = Person();\nconsole.log(a.name);//CrazyLee\nconsole.log(a.sex());//boy\n构造函数模式无需在函数内部重新创建对象，而是用this指代function Person() &#123;\n\tthis.name = 'CrazyLee';\n\tthis.age = '25';\n\tthis.sex = function()&#123;\n\t\treturn 'boy'\n\t&#125;;\n\t\n&#125;\n\nvar a = new Person();\nconsole.log(a.name);//CrazyLee\nconsole.log(a.sex());//boy\n原型模式函数中不对属性进行定义，利用prototype属性对属性进行定义，可以让所有对象实例共享它所包含的属性及方法function Parent() &#123;\n\tParent.prototype.name = 'carzy';\n\tParent.prototype.age = '24';\n\tParent.prototype.sex = function() &#123;\n\t&amp;emsp;var s=\"女\";\n\n&amp;emsp;&amp;emsp;&amp;emsp; console.log(s);\n\t&#125;\n&#125;\n\nvar  x =new  Parent();  \nconsole.log(x.name);      //crazy\nconsole.log(x.sex());       //女\n混合模式原型模式+构造函数模式。这种模式中，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性function Parent()&#123;  \n\tthis.name=\"CrazyLee\";  \n\tthis.age=24;  \n&#125;;\nParent.prototype.sayname=function()&#123;  \n\treturn this.name;  \n&#125;;\n\nvar x =new Parent(); \nconsole.log(x.sayname());   //Crazy&amp;emsp;&amp;emsp;\n动态原型模式将所有信息封装在了构造函数中，而通过构造函数中初始化原型，这个可以通过判断该方法是否有效而选择是否需要初始化原型function Parent()&#123;  \n\tthis.name=\"CrazyLee\";  \n\tthis.age=24;  \n\tif(typeof Parent._sayname==\"undefined\")&#123;     \n\t\tParent.prototype.sayname=function()&#123;  \n\t\t\treturn this.name;  \n\t\t&#125;  \n\t\tParent._sayname=true;  \n\t&#125;         \n&#125;;   \n\nvar x =new Parent();  \nconsole.log(x.sayname()); \n\n\n\n\n\n\n\n\n\n 参考：《原型设计模式以及JavaScript中的原型规则》\n\n\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"prototype-rules","date":"2023-02-20T08:10:45.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"97ef40e42114f03cdf27cd3432d76d80","title":"出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法","content":"一个经典的面试题\n0.1 + 0.2 === 0.3 // false\n\n精度丢失原因计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。\n0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数。\nJavaScript 中数字的存储遵循 IEEE 754 标准，是以 64 位双精度格式来存储数字的。\n一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。\n  根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：0.30000000000000004。\n最大数字、最大安全数\n能够表示的最大数字Number.MAX_VALUE等于1.7976931348623157e+308\n\n最大安全数字Number.MAX_SAFE_INTEGER等于9007199254740991\n\n\nJS处理最大数字的方法json-bigint官方示例\nvar JSONbig = require('json-bigint');\nvar JSONstrict = require('json-bigint')(&#123; strict: true &#125;);\n\nvar dupkeys = '&#123; \"dupkey\": \"value 1\", \"dupkey\": \"value 2\"&#125;';\nconsole.log('\\n\\nDuplicate Key test with both lenient and strict JSON parsing');\nconsole.log('Input:', dupkeys);\nvar works = JSONbig.parse(dupkeys);\nconsole.log('JSON.parse(dupkeys).dupkey: %s', works.dupkey);\nvar fails = 'will stay like this';\ntry &#123;\n  fails = JSONstrict.parse(dupkeys);\n  console.log('ERROR!! Should never get here');\n&#125; catch (e) &#123;\n  console.log(\n    'Succesfully catched expected exception on duplicate keys: %j',\n    e\n  );\n&#125;\n\n// 这些事打印内容\nDuplicate Key test with big number JSON\nInput: &#123; \"dupkey\": \"value 1\", \"dupkey\": \"value 2\"&#125;\nJSON.parse(dupkeys).dupkey: value 2\nSuccesfully catched expected exception on duplicate keys: &#123;\"name\":\"SyntaxError\",\"message\":\"Duplicate key \\\"dupkey\\\"\",\"at\":33,\"text\":\"&#123; \\\"dupkey\\\": \\\"value 1\\\", \\\"dupkey\\\": \\\"value 2\\\"&#125;\"&#125;\n\n\n参考：js大数字精度丢失问题\n处理精度缺失的方法toPrecision +s parseFloat使用 toPrecision 凑整并 parseFloat转成数字后再显示\n// 示例\nparseFloat(1.4000000000000001.toPrecision(12)) === 1.4  // True\n\n封装成方法就是：\nfunction strip(num, precision = 12) &#123;\n  return +parseFloat(num.toPrecision(precision));\n&#125;\n\nNumber.EPSILON在ES6中，提供了Number.EPSILON属性，而它的值就是2-52，只要判断0.1+0.2-0.3是否小于Number.EPSILON，如果小于，就可以判断为0.1+0.2 ===0.3\nfunction numberepsilon(arg1, arg2)&#123; \n    return Math.abs(arg1 - arg2) &lt; Number.EPSILON;\n&#125; \nconsole.log(numberepsilon(0.1 + 0.2, 0.3)); // true\n\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"loss-of-precision","date":"2023-02-17T09:17:28.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"8df75aa3038e84f242f016eb70dbbb6a","title":"可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用","content":"数值转换有三个函数可以将非数值转换为数值：Number()、parseInt()、parseFloat()。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。\n隐式类型转换\n涉及类型转换最多的两个运算符是+和==。+可以是字符串相加，也可以是数字相加，在操作符中存在字符串时，优先转换为字符串。\n−∗/- * /−∗/ 只针对Number类型，所以转换的结果只能是Number类型。\n\n三种转换转换为数字\n\n\n\n\n\n\n\n\nES定义所有对象都有toString()方法，无论它是伪对象还是对象。\n\n\n\n参数\n结果\n\n\n\nstring\n解析为数字，含有除了数字之外的字符，则转换为NAN\n\n\nboolean\ntrue-&gt;1 false-&gt;0\n\n\nundefined\nNAN\n\n\nnull\n+0\n\n\n[]\n+0\n\n\n[5]\n5\n\n\n{}\nNAN\n\n\n‘111’\n111 空字符串转为0 含有字符的字符串转为NaN\n\n\nSymbol\n报错\n\n\n转换为字符串\n\n\n参数\n结果\n\n\n\nboolean\ntrue-&gt;’true’ false-&gt;’false’\n\n\nundefined\n‘undefined’\n\n\nnull\n‘null’\n\n\nNumber\n直接转换，例如123-&gt;’123’\n\n\n[]\n“”\n\n\n[5,2]\n“5.2”\n\n\n{}\n‘[Object Object]’\n\n\nSymbol\n‘Symbol()’\n\n\n转换为布尔值\n\n\n参数\n结果\n\n\n\nstring\n除了空串都是’true’\n\n\nundefined\nfalse\n\n\nnull\nfalse\n\n\nNumber\n除了+0 -0 NaN之外其他都为true\n\n\n[]\ntrue\n\n\n{}\ntrue\n\n\nSymbol\ntrue\n\n\n===的判断\n===属于严格相等，直接判断两者的类型是否相同，不同则返回fals\n如果相同再比较大小，不会进行任何隐式转换\n对于引用类型来说，比较的都是引用内存地址，所以===这种方式的比较，除非两者存储的内存地址相同才相等，反之false\n\n==涉及的类型转换规则\n两边的类型是否相同，相同的话就比较值的大小。\n判断是否是null和undefined，是的话就返回true。\n判断类型是否是String和Numner，是的话就把String类型转成Number，再比较。\n判断一方是否是Boolean，是的话就把Boolean转换成Number，再进行比较。\n如果其中一方是Object，且另一方为String、Number或者Symbol，会将Object转换成字符串，再进行比较。\n\n[]==![]\n首先将![]转为布尔值，[]-&gt;true，!true-&gt;false，false-&gt;0\n[]-&gt;0 故0==0，返回true。\n\n对象转原始类型是根据什么流程运行的？对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数，其逻辑如下：\n\n如果Symbol.toPrimitive()方法，优先调用再返回\n调用valueof()，如果转换为原始类型就返回\n调用toString()，如果转换为原始类型就返回\n如果都没有返回原始类型，会报错\n\n并非所有对象的隐式转换都会按照这个流程进行，Date对象会优先尝试toString方法来实现转换，非Date对象按照上述顺序。\n\n\n\n类型\nvalueOf\ntoString\n\n\n\nObject\n对象本身，这是默认情况\n返回’[object ObjectName]’，其中ObjectName是对象类型的名称\n\n\nString\n字符串值\n返回String对象的值\n\n\nNumber\n数字值\n返回数值的字符串表示、还可以返回指定进制表示的字符串\n\n\nBoolean\nBoolean值\n为true，返回’true’；为false，返回’false’\n\n\nArray\n数组本身\n将Array的每个元素转为字符串，并将他们依次连接起来，两个元素之间用英文逗号作为分隔符进行拼接\n\n\nDate\n存储的时间是从1970年1月1月午夜开始计的毫秒数UTC\n返回日期的文本表示\n\n\nFunction\n函数本身\n返回如下格式的字符串，其中functionname是一个函数的名称，此函数的toString()方法被调用：”function functionname(){[native code]}”\n\n\n例子({} + {})\n进行ToPrimitive转换，由于没有指定PreferredType类型，{}会使默认值为Number，进行ToPrimitive(input, Number)运算。\n执行valueOf方法，({}).valueOf(),返回的还是{}对象，不是原始值。\n继续执行toString方法，({}).toString(),返回”[object Object]”，是原始值。 故得到最终的结果，”[object Object]” + “[object Object]” = “[object Object] [object Object]”\n\n2 * {}首先*运算符只能对number类型进行运算，故第一步就是对{}进行ToNumber类型转换。\n\n由于{}是对象类型，故先进行原始类型转换，ToPrimitive(input, Number)运算。\n执行valueOf方法，({}).valueOf(),返回的还是{}对象，不是原始值。\n继续执行toString方法，({}).toString(),返回”[object Object]”，是原始值。\n转换为原始值后再进行ToNumber运算，”[object Object]”就转换为NaN。 故最终的结果为 2 * NaN =NAN\n\n参考：《可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用》\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"implicit-type","date":"2023-02-17T03:46:34.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"3aa48ecd1d5414b4b0af011d9171a628","title":"至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型","content":"我们先复习一下js的数据类型。\nJavaScript 的数据类型包括原始类型和对象类型：\n\n原始类型：Null、Undefined、Number、String、Boolean、Symbol、BigInt\n对象类型：Object\n\n我们习惯把对象称为引用类型，当然还有很多特殊的引用类型，比如 Function、Array、RegExp、Math、Date、Error、Set、Map、各种定型数组 TypedArray 等。\n\nJavaScript 中检测数据类型的方法有哪些你知道吗？\n\n\n\n\n\n\n\n\n\n\ntypeof\ninstanceof\nconstructor\nObject.prototype.toString.call()\n\ntypeoftypeof 'a' // 'string'\ntypeof 1   // 'number' \ntypeof true // 'boolean'\ntypeof undefined // 'undefined'\ntypeof Symbol('a') // 'symbol'\ntypeof 1n // 'bigint'\n\ntypeof null // 'object'\n\ntypeof function() &#123;&#125; // 'function'\ntypeof [] // 'object'\ntypeof &#123;&#125; // 'object'\ntypeof /a/ // 'object'\ntypeof new Date() // 'object'\ntypeof new Error() // 'object'\ntypeof new Map() // 'object'\ntypeof new Set() // 'object'\n\n两条结论：\n\ntypeof 可以判断除了 null 以外的原始类型。\ntypeof 只能判断对象类型中的 Function，其他判断不出来，都为 object。\n\ninstanceofconsole.log(1 instanceof Number) // false\nconsole.log(new Number(1) instanceof Number) // true\n\nconst arr = []\nconsole.log(arr instanceof Array) // true\nconsole.log(arr instanceof Object) // true\n\nconst Fn = function() &#123;\n    this.name = '构造函数'\n&#125;\nFn.prototype = Object.create(Array.prototype)\nlet a = new Fn()\nconsole.log(a instanceof Array) // true\n\n两条结论：\n\ninstanceof 可以准确判断对象(引用)类型，但是不能准确检测原始类型。\n由于我们可以随意修改原型的指向导致检测结果不准确，所以这种方法是不安全的。\n\n虽然 instanceof 不能检测原始类型，但是有一种方法可以让其用于检测原始类型。\nSymbol.hasInstance 允许我们自定义 instanceof 的行为。\nclass PrimitiveNumber &#123;\n  static [Symbol.hasInstance] = x  => typeof x === 'number';\n&#125;\n123 instanceof PrimitiveNumber; // true\n\nclass PrimitiveString &#123;\n  static [Symbol.hasInstance] = x => typeof x === 'string';\n&#125;\n'abc' instanceof PrimitiveString; // true\n\nclass PrimitiveBoolean &#123;\n  static [Symbol.hasInstance] = x => typeof x === 'boolean';\n&#125;\nfalse instanceof PrimitiveBoolean; // true\n\nclass PrimitiveSymbol &#123;\n  static [Symbol.hasInstance] = x => typeof x === 'symbol';\n&#125;\nSymbol.iterator instanceof PrimitiveSymbol; // true\n\nclass PrimitiveNull &#123;\n  static [Symbol.hasInstance] = x => x === null;\n&#125;\nnull instanceof PrimitiveNull; // true\n\nclass PrimitiveUndefined &#123;\n  static [Symbol.hasInstance] = x => x === undefined;\n&#125;\nundefined instanceof PrimitiveUndefined; // true\n\n代码来源:  有没有一种方法可以将instanceof用于原始JavaScript值？\nconstructor// 所以需要加上一个小括号，小括号运算符能够把数值转换为对象\n(1).constructor // ƒ Number() &#123; [native code] &#125;\n// 或者\n1..constructor // ƒ Number() &#123; [native code] &#125;\n\nconst a = '前端食堂'\nconsole.log(a.constructor) // ƒ String() &#123; [native code] &#125;\nconsole.log(a.constructor === String) // true\n\nconst b = 5\nconsole.log(b.constructor) // ƒ Number() &#123; [native code] &#125;\nconsole.log(b.constructor === Number) // true\n\nconst c = true\nconsole.log(c.constructor) // ƒ Boolean() &#123; [native code] &#125;\nconsole.log(c.constructor === Boolean) // true\n\nconst d = []\nconsole.log(d.constructor) // ƒ Array() &#123; [native code] &#125;\nconsole.log(d.constructor === Array) // true\n\nconst e = &#123;&#125;\nconsole.log(e.constructor) // ƒ Object() &#123; [native code] &#125;\nconsole.log(e.constructor === Object) // true\n\nconst f = () => 1\nconsole.log(f.constructor) // ƒ Function() &#123; [native code] &#125;\nconsole.log(f.constructor === Function) // true\n\nconst g = Symbol('1')\nconsole.log(g.constructor) // ƒ Symbol() &#123; [native code] &#125;\nconsole.log(g.constructor === Symbol) // true\n\nconst h = new Date()\nconsole.log(h.constructor) // ƒ Date() &#123; [native code] &#125;\nconsole.log(h.constructor === Date) // true\n\nconst i = 11n\nconsole.log(i.constructor) // ƒ BigInt() &#123; [native code] &#125;\nconsole.log(i.constructor === BigInt) // true\n\nconst j = /a/\nconsole.log(j.constructor) // ƒ RegExp() &#123; [native code] &#125;\nconsole.log(j.constructor === RegExp) // true\n\n\nString.prototype.constructor = 'aaa'\nconsole.log(a.constructor === String) // false\n\nconst k = null\nconsole.log(k.constructor) // Cannot read property 'constructor' of null\n\nconst l = undefined\nconsole.log(l.constructor) // Cannot read property 'constructor' of undefined\n\n两条结论：\n\n除了 null 和 undefined，constructor 可以正确检测出原始类型和对象(引用)类型。\n由于我们可以随意修改 constructor 导致检测结果不准确，所以这种方法是不安全的。\n\nObject.prototype.toString.call()toString() 方法返回一个表示该对象的字符串，我们可以改变它的 this 指向，将 this 指向要检测的值，即可返回当前检测值的信息。\nObject.prototype.toString(&#123;&#125;) // '[object Object]'\n\nObject.prototype.toString.call(&#123;&#125;) // '[object Object]'\nObject.prototype.toString.call('a') // '[object String]'\nObject.prototype.toString.call(1) // '[object Number]'\nObject.prototype.toString.call(true) // '[object Boolean]'\nObject.prototype.toString.call(null) // '[object Null]'\nObject.prototype.toString.call(undefined) // '[object Undefined]'\nObject.prototype.toString.call(Symbol('a')) // '[object Symbol]'\nObject.prototype.toString.call(11n) // '[object BigInt]'\nObject.prototype.toString.call(/a/) // '[object RegExp]'\nObject.prototype.toString.call(new Date()) // '[object Date]'\nObject.prototype.toString.call([0, 1, 2]) // '[object Array]'\nObject.prototype.toString.call(function() &#123;&#125;) // '[object Function]'\nObject.prototype.toString.call(new Error()) // '[object Error]'\nObject.prototype.toString.call(new Set()) // '[object Set]'\nObject.prototype.toString.call(new Map()) // '[object Map]'\n\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"judgment-type-method","date":"2023-02-16T08:53:16.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"448cccd8063bd5883f40c05f4e533fff","title":"null和undefined的区别","content":"undefinedundefined 的字面意思就是：未定义的值 。这个值的语义是，希望表示一个变量最原始的状态，而非人为操作的结果 。 这种原始状态会在以下 4 种场景中出现：\n声明一个变量，但是没有赋var foo;\nconsole.log(foo); // undefined\n\n访问 foo，返回了 undefined，表示这个变量自从声明了以后，就从来没有使用过，也没有定义过任何有效的值。\n访问对象上不存在的属性或者未定义的变量console.log(Object.foo); // undefined\nconsole.log(typeof demo); // undefined\n\n访问 Object 对象上的 foo 属性，返回 undefined ， 表示Object 上不存在或者没有定义名为 foo 的属性；对未声明的变量执行typeof操作符返回了undefined值。\n函数定义了形参，但没有传递实参//函数定义了形参 a\nfunction fn(a) &#123;\n    console.log(a); // undefined\n&#125;\nfn(); //未传递实参\n\n函数 fn 定义了形参 a，但 fn 被调用时没有传递参数，因此，fn 运行时的参数 a 就是一个原始的、未被赋值的变量。\n使用void对表达式求值void 0 ; // undefined\nvoid false; // undefined\nvoid []; // undefined\nvoid null; // undefined\nvoid function fn()&#123;&#125; ; // undefined\n\nnullnull 的字面意思是：空值 。这个值的语义是，希望表示一个对象被人为的重置为空对象，而非一个变量最原始的状态 。 在内存里的表示就是，栈中的变量没有指向堆中的内存对象。\n特殊的typeof nulllet data = null;\nconsole.log(typeof data); // \"object\"\n\n\n\n相同点值相同console.log( undefined == null )//true\n\n转换Boolean的都是falseconsole.log( Boolean(undefined) )//false\nconsole.log( Boolean(null) )//false\n\n不同点数据类型不同console.log( undefined === null )//false     \n\n转换为Number类型的值不同console.log( Number(undefined) )//NaN\nconsole.log( Number(null) )//0\n\n总结\nundefined相当于期房。 买了房,但是房子还没建出来。(未定义)\n\nnull相当于毛坯房。买了房,但是房子没住人,里面是空的。(空值)\n\n值是undefined的变量和未声明的变量，typeof运算结果都是“undefined”。运算符typeof运算null的类型时返回“object”。\n\n通过禁止使用特殊值undefined，可以有效地确保只在一种情况下typeof才会返回“undefined”：当变量未声明时。这样就可以区别null和undefined。\n\n\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"null-undefined-diff","date":"2023-02-16T04:30:00.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"54ea49642993052fe31a24e3d7d4f0a2","title":"基本类型对应的内置对象，以及他们之间的装箱拆箱操作","content":"内置对象内置对象\nObject是JS中所有对象的父对象\n数据封装类对象：Object Array Boolean Number String\n其他对象：Function Math Date RegExp Error特殊的基本包装类型String Number Booleanarguments只存在函数内部的一个类数组对象装箱和拆箱装箱把基本数据类型转换为对应的引用数据类型的操作称为装箱，可以分为隐式装箱和显式装箱。\n\n隐式装箱\n\n\n\n\n\n\n\n\n\n每当读取一个基本类型的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。             ——《JavaScript高级程序设计》\nlet a='sun'\nlet b=a.indexOf('s')\n//上述代码在后台实际的步骤为\nlet a=new String('sun')\nlet b=a.indexOf('s')\na=null\n上述代码中，a是基本数据类型，不是对象，不应该具有方法，JS内部进行了装箱操作，使得它能够调用方法。执行完相应的方法之后立即被销毁。\n拆箱将引用数据类型转换为基本数据类型，通过valueOf()和toString()实现。\nlet a=new String('sun')//object\nlet b=new Number(12)//object\na.valueOf() //'sun' string\na.valueOf() //12 number\nb.toString()//'sun'string\nb.toString()//'12' string\n\n参考：《基本类型对应的内置对象，以及他们之间的装箱拆箱操作》\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"built-object","date":"2023-02-16T02:12:23.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"205cdbee45bbacca672eccc7f03221f2","title":"JavaScript中的变量在内存中的具体存储形式","content":"栈内存和堆内存\n\n\n\n\n\n\n\n\nJavaScript中的变量分为基本类型和引用类型 基本类型是保存在栈内存中的简单数据段，它们的值都有固定的大小，保存在栈空间，通过按值访问\n引用类型是保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用\n\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"js-storageForm","date":"2023-02-15T09:27:34.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"aea670576bd859851504cb5f27ad22f5","title":"Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol","content":"前言在 Es6 中引入了一个新的基础数据类型:Symbol,对于其他基本数据类型(数字number,布尔boolean,null,undefined,字符串string)想必都比较熟悉,但是这个Symbol平时用得很少,甚至在实际开发中觉得没有什么卵用,能够涉及到的应用场景屈指可数.\n解决的问题在 Es5 的对象属性名中都是字符串,当一对象的属性名出现重复时,后者往往会覆盖前者.若使用Symbol就能够保证每个属性的名字都是独一无二的,相当于生成一个唯一的标识 ID,这样就从根本上防止属性名的冲突\nSymbol 应用场景应用场景 1-使用Symbol来作为对象属性名(key)const PERSON_NAME = Symbol();\nconst PERSON_AGE = Symbol();\nlet person = &#123;\n    [PERSON_NAME]: \"随笔川迹\"\n&#125;\nperson[PERSON_AGE] =  20;\nconsole.log(person[PERSON_NAME])  // 随笔川迹\nconsole.log(person[PERSON_AGE])   // 20\n在上面的示例代码中,使用Symbol创建了PERSON_NAME,PERSON_AGE两个Symbol类型,但是在实际开发中却带来了一些问题。Symbol类型实例化出的key是不能通过Object.keys(),for..in,for..of,来枚举的。ES6中提供了 Object.getOwnPropertySymbols()方法,可以获取指定对象的所有Symbol属性名,该方法会返回一个数组\n应用场景 2：使用 Symbol 定义类的私有属性/方法let size = Symbol('size');  // 声明定义了一个size变量,类型是Symbol(),类型描述内容是size\n\nclass Collection &#123;          // class关键字定义了一个Collection类\n  constructor() &#123;           // 构造器`constructor`函数\n    this[size] = 0;         // 在当前类上私有化了一个size属性\n  &#125;\n\n  add(item) &#123;              // Collection类下的一个方法\n    this[this[size]] = item;\n    this[size]++;\n  &#125;\n\n  static sizeOf(instance) &#123; // 静态属性\n    return instance[size];\n  &#125;\n&#125;\n\nlet x = new Collection(); // 实例化x对象\nCollection.sizeOf(x) // 0\n\nx.add('foo');       // 调用方法\nCollection.sizeOf(x) // 1\n\nObject.keys(x) // ['0']\nObject.getOwnPropertyNames(x) // ['0']\nObject.getOwnPropertySymbols(x) // [Symbol(size)]\n上面代码中，对象 x 的 size 属性是一个 Symbol 值，所以 Object.keys(x)、Object.getOwnPropertyNames(x)都无法获取它。这就造成了一种非私有的内部方法的效果\n应用场景 3-模块化机制结合Symbol与模块化机制,类的私有属性和方法完美实现,如下代码所示 在文件a.js中\nconst PASSWORD = Symbol();  // 定义一个PASSWORD变量,类型是Symbol\n\nclass Login() &#123;      // class关键字声明一个Login类\n  constructor(username, password) &#123;    // 构造器函数内初始化属性\n    this.username = username;\n    this[PASSWORD] = password;\n  &#125;\n  checkPassword(pwd) &#123;\n    return this[PASSWORD] === pwd;\n  &#125;\n&#125;\nexport default Login;\n\n在文件b.js中\nimport Login from './a'\n\nconst login = new Login('itclanCoder', '123456'); // 实例化一个login对象\n\nlogin.checkPassword('123456'); // true\nlogin.PASSWORD;  // 访问不到\nlogin[PASSWORD]; // 访问不到\nlogin['PASSWORD'] // 访问不到\n\n因为通过Symbol定义的PASSWORD常量定义在a.js模块中,外面的模块是获取不到这个Symbol的,在外部无法引用这个值,也无法改写,也不可能在在创建一个一模一样的Symbol出来\n因为Symbol是唯一的\n在a.js模块中,这个PASSWORD的Symbol类型只能在当前模块文件(a.js)中内部使用,所以使用它来定义的类属性是没有办法被模块外访问到的\n这样就达到了一个私有化的效果\n应用场景 4-使用Symbol来替代常量在使用React中,结合Redux做公共数据状态管理时,当想要改变组件中的某个状态时,reducer是一个纯函数,它会返回一个最新的状态给store,返回的结果是由action和state共同决定的\naction是一个对象,有具体的类型type值,如果你写过几行Redux的代码,就会常常看到,进行action的拆分,将事件动作的类型定义成常量\n\nconst CHANGE_INPUT_VALUE = 'CHANGE_INPUT_VALUE';  // 监听input框输入值的常量\nconst ADD_INPUT_CONTENT = 'ADD_INPUT_CONTENT';    // 添加列表\nconst DELETE_LIST = 'DELETE_LIST';                // 删除列表\n\nfunction reducer(state, action) &#123;\n\tconst newState =  JSON.parse(JSON.stringify(state));\n  switch(action.type) &#123;\n    case CHANGE_INPUT_VALUE:\n      // ...\n    case ADD_INPUT_CONTENT:\n      // ...\n    case DELETE_LIST;\n      // ...\n    default:\n      return state;\n\t&#125;\n&#125;\n\n以上代码在Redux中很常见,将action对象中的type值,给抽离出来,定义一个常量存储,来代表一种业务逻辑,通常希望这些常量是唯一的,在Redux中定义成常量,是为了便于调试查错\n常常因为取type值时,非常苦恼.\n现在有了Symbol,改写一下,就可以这样\nconst CHANGE_INPUT_VALUE = Symbol()\nconst ADD_INPUT_CONTENT = Symbol();\nconst DELETE_LIST = Symbol()\n\nfunction reducer(state, action) &#123;\n\tconst newState =  JSON.parse(JSON.stringify(state));\n\tswitch(action.type) &#123;\n    case CHANGE_INPUT_VALUE:\n      // ...\n    case ADD_INPUT_CONTENT:\n      // ...\n    case DELETE_LIST;\n      // ...\n    default:\n      return state;\n\t&#125;\n&#125;\n\n通过Symbol定义字符串常量,就保证了三个常量的值唯一性\n划重点\n\n常量使用Symbol值最大的好处,就是其他任何值都不可能有相同的值了,可以保证常量的唯一性,因此,可以保证上面的switch语句按照你设计的方式条件去工作\n当Symbol值作为属性名时,该属性是公开属性,不是私有属性\n\n应用场景 5-注册和获取全局的 Symbol在浏览器窗口(window)中,使用Symbol()函数来定义生成的Symbol实例是唯一的\n但是若应用涉及到多个window,最常见的就是在各个页面窗口中嵌入iframe了,并在各个iframe页面中取到来自同一份公共的数据源\n也就是在各个window中使用的某些Symbol希望是同一个,那么这个时候,使用Symbol()就不行不通了\n因为用它在不同window中创建的Symbol实例总是唯一的，而我们需要的是在所有这些window环境下保持一个共享的Symbol值。\n在这种情况下，我们就需要使用另一个 API 来创建或获取Symbol，那就是Symbol.for()，它可以注册或获取一个window间全局的Symbol实例，它是Symbol的一个静态方法\n这个在前面已经提到过一次,这个还是有那么一点点用处,所以在提一嘴的\n如下示例代码所示\nlet gs1 = Symbol.for('global_symbol_1')  //注册一个全局Symbol\nlet gs2 = Symbol.for('global_symbol_1')  //获取全局Symbol\n\nconsole.log(gs1 === gs2 ) // true\n\n经过Symbol.for()实例化出来的Symbol字符串类型,只要描述的内容相同,那么不光是在当前window中是唯一的,在其他全局范围内的window也是唯一的,并且相同\n该特性,若是创建跨文件可用的symbol，甚至跨域（每个window都有它自己的全局作用域） , 可以使用 Symbol.for()取到相同的值\n也就是说,使用了Symbol.for()在全局范围内,Symbol类型值可以共享\n注意事项\nSymbol 值不能与其他类型的值进行运算-会报错\n\nlet symItclan = Symbol('itclan');\n\nconsole.log(\"主站\" + symItclan)\nconsole.log(`主站 $&#123;symItclan&#125;`) // Uncaught TypeError: Cannot convert a Symbol value to a string\n\n\nSymbol可以显示转为字符串\n\nlet SyItclanCoder = Symbol('https://coder.itclan.cn');\n\nconsole.log(String(SyItclanCoder)) // Symbol(https://coder.itclan.cn)\nconsole.log(SyItclanCoder.toString()) // Symbol(https://coder.itclan.cn)\n\n\nSymbol值可以转为布尔值,但是不能转为数值\n\nlet sym = Symbol();\nconsole.log(Boolean(sym)) // true\nconsole.log(!sym)  // false\n\nif (sym) &#123;\n  // ...\n&#125;\n\nNumber(sym) // TypeError  Cannot convert a Symbol value to a number\nsym + 2 // TypeError\n\n由上面的错误提示可以看出,Symbol不能转换为数字,无法做相应的运算\n\nSymbol函数不能使用new命令\n\nSymbol函数前不能使用new命令,否则就会报错,Symbol是一个原始类型的值,不是对象,它是类似字符串的数据类型\n\nSymbol值作为对象属性名时，不能用点运算符\n\n当Symbol值作为对象的属性名时,访问它时,不能用点运算符\nconst username = Symbol();\nconst person = &#123;&#125;;\nperson.username = '随笔川迹';\nperson[username]; // undefined\nperson['username']; // 随笔川迹\n\n第 4 行代码值为undefined,因为点运算符后面总是字符串,所以不会读取username作为标识符名所指代的那个值\n导致person对象的属性名实际上是一个字符串,而不是一个Symbol值\n由此可见:在对象内部,使用Symbol类型定义属性名时,Symbol值必须放在中括号之中\nlet s = Symbol();\nlet obj = &#123;\n  [s]: function(arg) &#123;\n    return arg;\n  &#125;\n&#125;\nobj[s](\"itclanCoder\")\n\n在上面的代码中,如果变量s不放在中括号中,该属性的键名就是字符串s,而不是定义Symbol类型值\n参考：《理解 Es6 中的 Symbol 类型》\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"symbol-devAndapp","date":"2023-02-15T09:27:34.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"54ad94266d02aab420ff03426bccde3c","title":"JavaScript对象的底层数据结构是什么","content":"上一篇文章归纳了javascript的数据类型，归根到底数据类型就分为两类，一种是基本类型，一种是引用类型。文章链接《JavaScript规定了几种语言类型》\n基本类型\n内容：String、Number、Boolean、Undefined、Null、Symbol、BigInt\n特点：值不可变，无属性无方法，保存在栈内存中、值比较。\n\n引用类型\n内容：引用类型统称为Object类型。细分的话有：Object、Array、Date、RegExp、Function  等特点：引用类型的值同时保存在栈内存和堆内存中的对象。栈区内存保存变量标识符，堆内存存储对象的地址\n\n什么是数据结构？数据结构是一种组织、管理和存储数据的形式，这种形式方便数据访问和修改。\nJavaScript使用的是 堆(Heap) 和 栈( Stack)堆\n是堆内存的简称，堆是动态分配内存，内存大小不固定，也不会自动释放\n\n队列优先,先进先出，方便存储和开辟内存空间。\n\n\n栈\n栈内存的简称，自动分配相对固定大小的内存空间，并由系统自动释放。\n基本类型存储在栈内存的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间\n线性结构，后进先出，便于管理。\n\n数据结构相关 — 浅拷贝、深拷贝浅拷贝创建新的数据，这个数据有着原始数据属性值的一份精确拷贝\n浅拷贝是拷贝一层，深层次的引用类型则共享内存地址\n\n\n\n\n\n\n\n\n\n浅拷贝实现方法：\n\nObject.assign\nslice()\nconcat()\n拓展运算符 …\n\nObject.assignlet obj = &#123;\n    age: 18,\n    nature: ['smart', 'good'],\n    names: &#123;\n        name1: 'fx',\n        name2: 'xka'\n    &#125;,\n    love: function () &#123;\n        console.log('fx is a great girl')\n    &#125;\n&#125;\nvar newObj = Object.assign(&#123;&#125;, obj);\n\nslice()const fxArr = [\"One\", \"Two\", \"Three\"]\nconst fxArrs = fxArr.slice(0)\nfxArrs[1] = \"love\";\nconsole.log(fxArr) // [\"One\", \"Two\", \"Three\"]\nconsole.log(fxArrs) // [\"One\", \"love\", \"Three\"]\n\nconcat()const fxArr = [\"One\", \"Two\", \"Three\"]\nconst fxArrs = fxArr.concat()\nfxArrs[1] = \"love\";\nconsole.log(fxArr) // [\"One\", \"Two\", \"Three\"]\nconsole.log(fxArrs) // [\"One\", \"love\", \"Three\"]\n\n拓展运算符 …onst fxArr = [\"One\", \"Two\", \"Three\"]\nconst fxArrs = [...fxArr]\nfxArrs[1] = \"love\";\nconsole.log(fxArr) // [\"One\", \"Two\", \"Three\"]\nconsole.log(fxArrs) // [\"One\", \"love\", \"Three\"]\n\n深拷贝深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性\n\n\n\n\n\n\n\n\n\n  实现方法：\n\n_.cloneDeep()\njQuery.extend()\nJSON.stringify()\n手写循环递归\n\n_.cloneDeep()const _ = require('lodash');\nconst obj1 = &#123;\n    a: 1,\n    b: &#123; f: &#123; g: 1 &#125; &#125;,\n    c: [1, 2, 3]\n&#125;;\nconst obj2 = _.cloneDeep(obj1);\nconsole.log(obj1.b.f === obj2.b.f);// false\n\njQuery.extend()const $ = require('jquery');\nconst obj1 = &#123;\n    a: 1,\n    b: &#123; f: &#123; g: 1 &#125; &#125;,\n    c: [1, 2, 3]\n&#125;;\nconst obj2 = $.extend(true, &#123;&#125;, obj1);\nconsole.log(obj1.b.f === obj2.b.f); // false\n\nJSON.stringify()const obj2=JSON.parse(JSON.stringify(obj1));\n// 但是这种方式存在弊端，会忽略undefined、symbol和函数\n\n手写循环递归function deepClone(obj, hash = new WeakMap()) &#123;\n  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作\n  if (obj instanceof Date) return new Date(obj);\n  if (obj instanceof RegExp) return new RegExp(obj);\n  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝\n  if (typeof obj !== \"object\") return obj;\n  // 是对象的话就要进行深拷贝\n  if (hash.get(obj)) return hash.get(obj);\n  let cloneObj = new obj.constructor();\n  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身\n  hash.set(obj, cloneObj);\n  for (let key in obj) &#123;\n    if (obj.hasOwnProperty(key)) &#123;\n      // 实现一个递归拷贝\n      cloneObj[key] = deepClone(obj[key], hash);\n    &#125;\n  &#125;\n  return cloneObj;\n&#125;\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"js-data-structure","date":"2023-02-15T05:21:00.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"be69bcf460f3a988c3f4f8fd1e3998bb","title":"JavaScript规定了几种语言类型","content":"前言JavaScript是什么？这里引用百度百科的说法\n\n\n\n\n\n\n\n\n\nJavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式、声明式、函数式编程范式。\n语言类型ps：检测数据类型的操作符typeof\nBoolean：布尔值，true或者false，表示逻辑上的真和假【基本类型】let a = true;\ntypeof a;    // 'boolean'\n\nnumber：数字【基本类型】// 数字类型，最大2^53 - 1，即 9007199254740991，大于这个值可能会失去精度\nlet a = 9007199254740991;\nlet b = 90071992547409911;\nlet c = NaN;    // NaN是特殊的number类型\nconsole.log(a);    // 9007199254740991\nconsole.log(b);    // 90071992547409900 失去精度\ntypeof a;    // 'number'\ntypeof c;    // 'number'\n\nstring：字符串【基本类型】// 字符串类型\nlet a = 'aaa';\ntypeof a;    // 'string'\n\nundefined：未定义【基本类型】// 声明了但未定义值\nlet a;\nconsole.log(a); // undefined\ntypeof(a); // 'undefined'\n\nnull：空值【基本类型】// 空值\nlet a = null;\ntypeof a;    // object\n\nps: 虽然typeof null为object，但这只是JavaScript 存在的一个悠久 Bug，不代表null就是引用数据类型，并且null本身也不是对象\nsymbol： 独一无二的值【基本类型】// 独一无二的值\nlet a = Symbol();\ntypeof a;    // symbol\n\nps: ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。Symbol类型实例化出的key是不能通过Object.keys(),for..in,for..of,来枚举的\nBigInt: 大整数【基本类型】// 要创建 a `BigInt`，请将 n 附加到整数末尾或调用 BigInt()\nlet a = 999n;\nlet b = BigInt(999);\ntypeof a;    // 'bigint'\ntypeof b;    // 'bigint'\n\nps: BigInt目前已经进入Stage 4阶段 下一个版本将会作为新特性出现在ECMAScript 。BigInt是JavaScript中一种可以用来表示任意精度整数的基本数据类型。使用BigInt可以安全的存储和操作任意大小的整数而不受Number类型的安全值范围的限制\nobject：对象，包含array,date等【引用类型】let a = [];\nlet b = &#123;&#125;;\nlet c = new Date();\ntypeof a;    // 'object'\ntypeof b;    // 'object'\ntypeof c;    // 'object'\n\nps：文末附上汇总文章链接《一名【合格】前端工程师的自检清单【自检ing】》\n","slug":"js-specThe-langType","date":"2023-02-15T03:34:00.000Z","categories_index":"前端,自检清单,JS","tags_index":"前端,自检清单,JS","author_index":"手可摘星陈"},{"id":"a9932dfc783681953ee77924badfcfab","title":"一名【合格】前端工程师的自检清单【自检ing】","content":"前言感谢原作者提供这样一份优秀的自检清单，写这篇的文章的主要目的是按照清单上的知识检测自己还有哪些不足和提升，同时建立自己的知识体系原文章地址: 一名【合格】前端工程师的自检清单\n\n一、JavaScript基础\n\n\n\n\n\n\n\n\n前端工程师吃饭的家伙，深度、广度一样都不能差。\n变量和类型\n1.JavaScript规定了几种语言类型\n\n2.JavaScript对象的底层数据结构是什么\n\n3.Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol\n\n4.JavaScript中的变量在内存中的具体存储形式\n\n5.基本类型对应的内置对象，以及他们之间的装箱拆箱操作\n\n6.理解值类型和引用类型\n\n7.null和undefined的区别\n\n8.至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型\n\n9.可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用\n\n10.出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法\n原型和原型链\n1.理解原型设计模式以及JavaScript中的原型规则\n\n2.instanceof的底层实现原理，手动实现一个instanceof\n\n4.实现继承的几种方式以及他们的优缺点\n\n5.至少说出一种开源项目(如Node)中应用原型继承的案例\n\n6.可以描述new一个对象的详细过程，手动实现一个new操作符\n\n7.理解es6 class构造以及继承的底层实现原理\n作用域和闭包\n1.理解词法作用域和动态作用域\n\n2.理解JavaScript的作用域和作用域链\n\n3.理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题\n\n4.this的原理以及几种不同使用场景的取值\n\n5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用\n\n6.理解堆栈溢出和内存泄漏的原理，如何防止\n\n7.如何处理循环的异步操作\n\n8.理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理\n执行机制\n1.为何try里面放return，finally还会执行，理解其内部机制\n\n2.JavaScript如何实现异步编程，可以详细描述EventLoop机制\n\n3.宏任务和微任务分别有哪些\n\n4.可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法\n\n5.使用Promise实现串行\n\n6.Node与浏览器EventLoop的差异\n\n7.如何在保证页面运行流畅的情况下处理海量数据\n语法和API\n1.理解ECMAScript和JavaScript的关系\n\n2.熟练运用es5、es6提供的语法规范，\n\n3.熟练掌握JavaScript提供的全局对象（例如Date、Math）、全局函数（例如decodeURI、isNaN）、全局属性（例如Infinity、undefined）\n\n4.熟练应用map、reduce、filter 等高阶函数解决问题\n\n5.setInterval需要注意的点，使用settimeout实现setInterval\n\n6.JavaScript提供的正则表达式API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题\n\n7.JavaScript异常处理的方式，统一的异常处理方案\n二、HTML和CSSHTML\n1.从规范的角度理解HTML，从分类和语义的角度使用标签\n\n2.常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式\n\n3.元信息类标签(head、title、meta)的使用目的和配置方法\n\n4.HTML5离线缓存原理\n\n5.可以使用Canvas API、SVG等绘制高性能的动画\nCSS\n1.CSS盒模型，在不同浏览器的差异\n\n2.CSS所有选择器及其优先级、使用场景，哪些可以继承，如何运用at规则\n\n3.CSS伪类和伪元素有哪些，它们的区别和实际应用\n\n4.HTML文档流的排版规则，CSS几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理\n\n5.水平垂直居中的方案、可以实现6种以上并对比它们的优缺点\n\n6.BFC实现原理，可以解决的问题，如何创建BFC\n\n7.可使用CSS函数复用代码，实现特殊效果\n\n8.PostCSS、Sass、Less的异同，以及使用配置，至少掌握一种\n\n9.CSS模块化方案、如何配置按需加载、如何防止CSS阻塞渲染\n\n10.熟练使用CSS实现常见动画，如渐变、移动、旋转、缩放等等\n\n11.CSS浏览器兼容性写法，了解不同API在不同浏览器下的兼容性情况\n\n12.掌握一套完整的响应式布局方案\n手写\n1.手写图片瀑布流效果\n\n2.使用CSS绘制几何图形（圆形、三角形、扇形、菱形等）\n\n3.使用纯CSS实现曲线运动（贝塞尔曲线）\n\n4.实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点\n三、计算机基础\n\n\n\n\n\n\n\n\n关于编译原理，不需要理解非常深入，但是最基本的原理和概念一定要懂，这对于学习一门编程语言非常重要\n编译原理\n1.理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序\n\n2.正则表达式的匹配原理和性能优化\n\n3.如何将JavaScript代码解析成抽象语法树(AST)\n\n4.base64的编码原理\n\n5.几种进制的相互转换计算方法，在JavaScript中如何表示和转换\n网络协议\n1.理解什么是协议，了解TCP/IP网络协议族的构成，每层协议在应用程序中发挥的作用\n\n2.三次握手和四次挥手详细原理，为什么要使用这种机制\n\n3.有哪些协议是可靠，TCP有哪些手段保证可靠交付\n\n4.DNS的作用、DNS解析的详细过程，DNS优化原理\n\n5.CDN的作用和原理\n\n6.HTTP请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么\n\n7.HTTP所有状态码的具体含义，看到异常状态码能快速定位问题\n\n8.HTTP1.1、HTTP2.0带来的改变\n\n9.HTTPS的加密原理，如何开启HTTPS，如何劫持HTTPS请求\n\n10.理解WebSocket协议的底层原理、与HTTP的区别\n设计模式\n1.熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等\n\n2.发布订阅模式和观察者模式的异同以及实际应用\n\n3.可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用\n四、数据结构和算法\n\n\n\n\n\n\n\n\n据我了解的大部分前端对这部分知识有些欠缺，甚至抵触，但是，如果突破更高的天花板，这部分知识是必不可少的，而且我亲身经历——非常有用！\nJavaScript编码能力\n1.种方式实现数组去重、扁平化、对比优缺点\n\n2.多种方式实现深拷贝、对比优缺点\n\n3.手写函数柯里化工具函数、并理解其应用场景和优势\n\n4.手写防抖和节流工具函数、并理解其内部原理和应用场景\n\n5.实现一个sleep函数\n手动实现前端轮子\n1.手动实现call、apply、bind\n\n2.手动实现符合Promise/A+规范的Promise、手动实现async await\n\n3.手写一个EventEmitter实现事件发布、订阅\n\n4.可以说出两种实现双向绑定的方案、可以手动实现\n\n5.手写JSON.stringify、JSON.parse\n\n6.手写一个模版引擎，并能解释其中原理\n\n7.手写懒加载、下拉刷新、上拉加载、预加载等效果\n数据结构\n1.理解常见数据结构的特点，以及他们在不同场景下使用的优缺点\n\n2.理解数组、字符串的存储原理，并熟练应用他们解决问题\n\n3.理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题\n\n4.了解图、堆的基本结构和使用场景\n算法\n1.可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗\n\n2.至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度\n\n3.了解递归和循环的优缺点、应用场景、并可在开发中熟练应用\n\n4.可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题\n\n5.前端处理海量数据的算法方案\n五、运行环境我们需要理清语言和环境的关系：\n\n\n\n\n\n\n\n\n\nECMAScript描述了JavaScript语言的语法和基本对象规范浏览器作为JavaScript的一种运行环境，为它提供了：文档对象模型（DOM），描述处理网页内容的方法和接口、浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口Node也是JavaScript的一种运行环境，为它提供了操作I/O、网络等API\n浏览器API\n1.浏览器提供的符合W3C标准的DOM操作API、浏览器差异、兼容性\n\n2.浏览器提供的浏览器对象模型 (BOM)提供的所有全局API、浏览器差异、兼容性\n\n3.大量DOM操作、海量数据的性能优化(合并操作、Diff、requestAnimationFrame等)\n\n4.浏览器海量数据存储、操作性能优化\n\n5.DOM事件流的具体实现机制、不同浏览器的差异、事件代理\n\n6.前端发起网络请求的几种方式及其底层实现、可以手写原生ajax、fetch、可以熟练使用第三方库\n\n7.浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型\n\n8.浏览器提供的几种存储机制、优缺点、开发中正确的选择\n\n9.浏览器跨标签通信\n浏览器原理\n1.各浏览器使用的JavaScript引擎以及它们的异同点、如何在代码中进行区分\n\n2.请求数据到请求结束与服务器进行了几次交互\n\n3.可详细描述浏览器从输入URL到页面展现的详细过程\n\n4.浏览器解析HTML代码的原理，以及构建DOM树的流程\n\n5.浏览器如何解析CSS规则，并将其应用到DOM树上\n\n6.浏览器如何将解析好的带有样式的DOM树进行绘\n\n7.浏览器的运行机制，如何配置资源异步同步加载\n\n8.浏览器回流与重绘的底层原理，引发原因，如何有效避免\n\n9.浏览器的垃圾回收机制，如何避免内存泄漏\n\n10.浏览器采用的缓存方案，如何选择和控制合适的缓存方案\nNode\n1.理解Node在应用程序中的作用，可以使用Node搭建前端运行环境、使用Node操作文件、操作数据库等等\n\n2.掌握一种Node开发框架，如Express，Express和Koa的区别\n\n3.熟练使用Node提供的API如Path、Http、Child Process等并理解其实现原理\n\n4.Node的底层运行原理、和浏览器的异同\n\n5.Node事件驱动、非阻塞机制的实现原理\n六、框架和类库\n\n\n\n\n\n\n\n\n轮子层出不穷，从原理上理解才是正道\nTypeScript\n1.理解泛型、接口等面向对象的相关概念，TypeScript对面向对象理念的实现\n\n2.理解使用TypeScript的好处，掌握TypeScript基础语法\n\n3.TypeScript的规则检测原理\n\n4.可以在React、Vue等框架中使用TypeScript进行开发\nReact\n1.React和vue 选型和优缺点、核心架构的区别\n\n2.React中setState的执行机制，如何有效的管理状态\n\n3.React的事件底层实现机制\n\n4.React的虚拟DOM和Diff算法的内部实现\n\n5.React的Fiber工作原理，解决了什么问题\n\n6.React Router和Vue Router的底层实现原理、动态加载实现原理\n\n7.可熟练应用React API、生命周期等，可应用HOC、render props、Hooks等高阶用法解决问题\n\n8.基于React的特性和原理，可以手动实现一个简单的React\nVue\n1.熟练使用Vue的API、生命周期、钩子函数\n\n2.MVVM框架设计理念\n\n3.Vue双向绑定实现原理、Diff算法的内部实现\n\n4.Vue的事件机制\n\n5.从template转换成真实DOM的实现机制\n多端开发\n1.单页面应用（SPA）的原理和优缺点，掌握一种快速开发SPA的方案\n\n2.理解Viewport、em、rem的原理和用法，分辨率、px、ppi、dpi、dp的区别和实际应用\n\n3.移动端页面适配解决方案、不同机型适配方案\n\n4.掌握一种JavaScript移动客户端开发技术，如React Native：可以搭建React Native开发环境，熟练进行开发，可理解React Native的运作原理，不同端适配\n\n5.掌握一种JavaScript PC客户端开发技术，如Electron：可搭建Electron开发环境，熟练进行开发，可理解Electron的运作原理\n\n6.掌握一种小程序开发框架或原生小程序开发\n\n7.理解多端框架的内部实现原理，至少了解一个多端框架的使用\n数据流管理\n1.掌握React和Vue传统的跨组件通信方案，对比采用数据流管理框架的异同\n\n2.熟练使用Redux管理数据流，并理解其实现原理，中间件实现原理\n\n3.熟练使用Mobx管理数据流，并理解其实现原理，相比Redux有什么优势\n\n4.熟练使用Vuex管理数据流，并理解其实现原理\n\n5.以上数据流方案的异同和优缺点，不情况下的技术选型\n实用库\n1.至少掌握一种UI组件框架，如antd design，理解其设计理念、底层实现\n\n2.掌握一种图表绘制框架，如Echart，理解其设计理念、底层实现，可以自己实现图表\n\n3.掌握一种GIS开发框架，如百度地图API\n\n4.掌握一种可视化开发框架，如Three.js、D3\n\n5.工具函数库，如lodash、underscore、moment等，理解使用的工具类或工具函数的具体实现原理\n开发和调试\n1.熟练使用各浏览器提供的调试工具\n\n2.熟练使用一种代理工具实现请求代理、抓包，如charls\n\n3.可以使用Android、IOS模拟器进行调试，并掌握一种真机调试方案\n\n4.了解Vue、React等框架调试工具的使用\n七、前端工程\n\n\n\n\n\n\n\n\n前端工程化：以工程化方法和工具提高开发生产效率、降低维护难度\n项目构建\n1.理解npm、yarn依赖包管理的原理，两者的区别\n\n2.可以使用npm运行自定义脚本\n\n3.理解Babel、ESLint、webpack等工具在项目中承担的作用\n\n4.ESLint规则检测原理，常用的ESLint配置\n\n5.Babel的核心原理，可以自己编写一个Babel插件\n\n6.可以配置一种前端代码兼容方案，如Polyfill\n\n7.Webpack的编译原理、构建流程、热更新原理，chunk、bundle和module的区别和应用\n\n8.可熟练配置已有的loaders和plugins解决问题，可以自己编写loaders和plugins\nnginx\n1.正向代理与反向代理的特点和实例\n\n2.可手动搭建一个简单的nginx服务器、\n\n3.熟练应用常用的nginx内置变量，掌握常用的匹配规则写法\n\n4.可以用nginx实现请求过滤、配置gzip、负载均衡等，并能解释其内部原理\n开发提速\n1.熟练掌握一种接口管理、接口mock工具的使用，如yapi\n\n2.掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题\n\n3.理解TDD与BDD模式，至少会使用一种前端单元测试框架\n版本控制\n1.理解Git的核心原理、工作流程、和SVN的区别\n\n2.熟练使用常规的Git命令、git rebase、git stash等进阶命令\n\n3.可以快速解决线上分支回滚、线上分支错误合并等复杂问题\n持续集成\n1.理解CI/CD技术的意义，至少熟练掌握一种CI/CD工具的使用，如Jenkins\n\n2.可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括Web应用、移动客户端应用、PC客户端应用、小程序、H5等等）\n八、项目和业务后端技能\n1.了解后端的开发方式，在应用程序中的作用，至少会使用一种后端语言\n\n2.掌握数据最终在数据库中是如何落地存储的，能看懂表结构设计、表之间的关联，至少会使用一种数据库\n性能优化\n1.了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案\n\n2.了解常见的Web、App性能优化方案\n\n3.SEO排名规则、SEO优化方案、前后端分离的SEO\n\n4.SSR实现方案、优缺点、及其性能优化\n\n5.Webpack的性能优化方案\n\n6.Canvas性能优化方案\n\n7.React、Vue等框架使用性能优化方案\n前端安全\n1.XSS攻击的原理、分类、具体案例，前端如何防御\n\n2.CSRF攻击的原理、具体案例，前端如何防御\n\n3.HTTP劫持、页面劫持的原理、防御措施\n业务相关\n1.能理解所开发项目的整体业务形态、业务目标、业务架构，可以快速定位线上业务问题\n\n2.能理解所开发项目整体的技术架构、能快读的根据新需求进行开发规划、能快速根据业务报警、线上日志等定位并解决线上技术问题\n\n3.可以将自己的想法或新技术在业务中落地实践，尽量在团队中拥有一定的不可替代性\n\n\n","slug":"self-check-list","date":"2023-02-14T02:15:00.000Z","categories_index":"前端,自检清单","tags_index":"前端,自检清单","author_index":"手可摘星陈"},{"id":"4298a08c1e0e68f5aeb283438517f755","title":"nginx配置","content":"服务器 nginx 配置一般目录地址：\n/etc/nginx\n\nnginx.conf 配置示例# For more information on configuration, see:\n#   * Official English Documentation: http://nginx.org/en/docs/\n#   * Official Russian Documentation: http://nginx.org/ru/docs/\n\nuser www-data;\nworker_processes auto;\nworker_rlimit_nofile 65535;\nerror_log /var/log/nginx/error.log;\npid /run/nginx.pid;\n\n# Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.\n# include /usr/share/nginx/modules/*.conf;\n\nevents &#123;\n    worker_connections 1024;\n&#125;\n\nhttp &#123;\n\n    include             /etc/nginx/mime.types;\n    default_type        application/octet-stream;\n\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    access_log  /var/log/nginx/access.log  main;\n\n    sendfile            on;\n    #tcp_nopush          on;\n    tcp_nodelay         on;\n    keepalive_timeout   100;\n    types_hash_max_size 2048;\n    client_max_body_size 100m;\n    underscores_in_headers on;\n\n    server_names_hash_max_size 1024;\n    server_names_hash_bucket_size 64;\n\n    # Load modular configuration files from the /etc/nginx/conf.d directory.\n    # See http://nginx.org/en/docs/ngx_core_module.html#include\n    # for more information.\n    include /etc/nginx/conf.d/*.conf;\n    include /etc/nginx/sites-enabled/*;\n\n# Settings for a TLS enabled server.\n#\n#    server &#123;\n#        listen       443 ssl http2 default_server;\n#        listen       [::]:443 ssl http2 default_server;\n#        server_name  _;\n#        root         /usr/share/nginx/html;\n#\n#        ssl_certificate \"/etc/pki/nginx/server.crt\";\n#        ssl_certificate_key \"/etc/pki/nginx/private/server.key\";\n#        ssl_session_cache shared:SSL:1m;\n#        ssl_session_timeout  10m;\n#        ssl_ciphers HIGH:!aNULL:!MD5;\n#        ssl_prefer_server_ciphers on;\n#\n#        # Load configuration files for the default server block.\n#        include /etc/nginx/default.d/*.conf;\n#\n#        location / &#123;\n#        &#125;\n#\n#        error_page 404 /404.html;\n#        location = /404.html &#123;\n#        &#125;\n#\n#        error_page 500 502 503 504 /50x.html;\n#        location = /50x.html &#123;\n#        &#125;\n#    &#125;\n\n&#125;\n\n\nconf.d 文件夹配置示例# 文件名起 xxx.conf\n# 配置示例\n\n# jenkins.conf 示例\nserver &#123;\n    listen 80;\n    server_name jenkins.xxx.xxx.xxx;\n\n    access_log /etc/nginx/logs/jenkins.access.log main;\n    error_log /etc/nginx/logs/jenkins.error.log warn;\n\n    location / &#123;\n        proxy_pass http://localhost:8080;\n    &#125;\n&#125;\n\n# 站点配置示例\n# xxx.conf\nserver &#123;\n    listen 80;\n    server_name ~^([a-zA-Z0-9-]+)\\.pda-dev\\.xxx(域名配置)\\.xxx(域名配置)\\.xxx(域名配置)$;\n    set $platform $1;\n\n    charset utf-8;\n    access_log /etc/nginx/logs/pda.admin.dev.access.log main;\n    error_log /etc/nginx/logs/pda.admin.dev.error.log error;\n\n    location @rewrites &#123;\n        rewrite ^.*$ /index.html last;\n    &#125;\n\n    location /api &#123;\n        proxy_pass http://api.pda-dev-admin.xxx(域名配置);\n    &#125;\n\n    location / &#123;\n        root /mnt/data/www/frontend_deploy_workspace/dev/pda/$platform;\n        try_files $uri $uri/ @rewrites;\n        index index.html;\n    &#125;\n&#125;\n","slug":"xu9t5l","date":"2021-12-19T09:08:00.000Z","categories_index":"nginx","tags_index":"nginx","author_index":"手可摘星陈"},{"id":"bddf5d070a36a0f1beeaeeaa433a90bd","title":"ubuntu 部署jenkins","content":"服务器部署 jenkinsjenkinsci/blueocean 安装docker pull jenkinsci/blueocean\ndoker 部署 jenkinsdocker run -d -u root --name jenkins -p 8080:8080 -p 50000:50000 -v /data/jenkins_home:/var/jenkins_home jenkinsci/blueocean:lts\n\ndocker run -d -u root --name jenkins -p 8080:8080 -p 50000:50000 -v /workspace/data/jenkins:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v /etc/timezone:/etc/timezone -v /etc/localtime:/etc/localtime jenkinsci/blueocean:1.25.1\n\n查看 Jenkins 启动情况# 查看启动项\ndocker ps\n# 查看全部\ndocker ps -a\n\n遇到的问题Jenkins 容器 docker run 之后状态 Exited# 查看docker日志 ：\ndocker logs jenkins\n发现是目前权限问题\n因为/data/jenkins_home 目录是root权限\n\n解决方法chown -R 1000 /data/jenkins_home //用户组改变\n\nJenkins 首次登录需要密码// 进入容器\ndocker exec -it de20d10b6046（容器id） bash\ncat /var/jenkins_home/secrets/initialAdminPassword //查看密码\n\njenkins 部署项目添加节点进入容器 创建 ssh 证书 连接寄主机# 生成证书\nssh-keygen -t rsa -C \"kingpi@163.com\" -f ~/.ssh/host-rsa\n# 进入.ssh\ncd ~/.ssh\n\n添加 configHost 172.17.0.1（寄主机docker ip）\n  HostName 172.17.0.1\n  User root\n  PreferredAuthentications publickey\n  IdentityFile ~/.ssh/host-rsa\n\n寄主机进入 ~/.sshcd ~/.ssh\n\n进入文件 authorizedkeysvi authorized_keys\n# 输入 上面创建的 连接寄主机 ssh证书公钥\n\njenkins 添加 节点\njenkins 容器内创建连接 github 证书ssh-keygen -t rsa -C \"kingpi@163.com\" -f ~/.ssh/github.com\n# config 添加host\n\njenkins 添加凭证 如上面 图连接远程服务器jenkins 容器内创建证书ssh-keygen -t rsa -C \"kingpi@163.com\" -m PEM -P \"\" -f ~/.ssh/yooleap.net\n# config 添加host\n\njenkins 系统配置配置服务器信息 添加上私钥\n遇到的问题# 连接服务器测试报错\njenkins.plugins.publish_over.BapPublisherException: Failed to add SSH key. Message [invalid privatekey: [B@59df330d]_\n\n# 解决方法\nssh openSSH 版本过高 改用RSA\nssh-keygen -t rsa -C \"kingpi@163.com\" -m PEM -P \"\" -f ~/.ssh/yooleap.net\n","slug":"dhm7uz","date":"2021-12-10T03:10:00.000Z","categories_index":"jenkins部署","tags_index":"jenkins,ubuntu","author_index":"手可摘星陈"},{"id":"0e3cfafab513b2ddf7256c9eacf77c51","title":"element-plus修改主题色","content":"先安装 vite 构建工具# 先安装 vite 构建工具\nnpm install -g create-vite-app\n\n创建项目：# 下面两个命令都可以\ncreate-vite-app vue3-demo\ncva vue3-demo\n\n按照官网修改主题色官网我选择的是通过 scss 修改主题色例子参照：element-plus-vite-starter\n创建 index.scss 文件# ./styles/element/index.scss\n$--colors: (\n  \"primary\": (\n    \"base\": #ee4444,\n  ),\n  \"success\": (\n    \"base\": #21ba45,\n  ),\n  \"warning\": (\n    \"base\": #f2711c,\n  ),\n  \"danger\": (\n    \"base\": #db2828,\n  ),\n  \"error\": (\n    \"base\": #db2828,\n  ),\n  \"info\": (\n    \"base\": #42b8dd,\n  ),\n);\n\n@forward \"element-plus/theme-chalk/src/common/var.scss\" with\n  (\n    // do not use same name, it will override.\n    $colors: $--colors,\n    $button-padding-horizontal: (\"default\": 50px)\n  );\n\n\nvue.config.ts 代码如下import path from \"path\";\nimport &#123; defineConfig &#125; from \"vite\";\nimport vue from \"@vitejs/plugin-vue\";\n\nimport Components from \"unplugin-vue-components/vite\";\nimport &#123; ElementPlusResolver &#125; from \"unplugin-vue-components/resolvers\";\n\n// https://vitejs.dev/config/\nexport default defineConfig(&#123;\n  resolve: &#123;\n    alias: &#123;\n      \"~/\": `$&#123;path.resolve(__dirname, \"src\")&#125;/`,\n    &#125;,\n  &#125;,\n  css: &#123;\n    preprocessorOptions: &#123;\n      scss: &#123;\n        additionalData: `@use \"~/styles/element/index.scss\" as *;`,\n      &#125;,\n    &#125;,\n  &#125;,\n  plugins: [\n    vue(),\n    Components(&#123;\n      resolvers: [\n        ElementPlusResolver(&#123;\n          importStyle: \"sass\",\n        &#125;),\n      ],\n    &#125;),\n  ],\n&#125;);\n","slug":"ual5ig","date":"2021-11-01T03:21:00.000Z","categories_index":"Vue","tags_index":"vue3,vue,element-plus","author_index":"手可摘星陈"},{"id":"f75c33a49b8a527fa8975e81f9d8e4eb","title":"vue3 使用 百度地图","content":"Vue3 使用 百度地图的报错的问题vue3 项目中使用百度地图总是报错 BMap is not defined.\npublic/index.html 中加入&lt;script\n  type=\"text/javascript\"\n  src=\"http://api.map.baidu.com/api?v=3.0&amp;ak=你的ak\"\n>&lt;/script>\n\n.eslintrc.js 中加入module.exports = &#123;\n  ...,\n  globals: &#123;\n     BMap: true\n  &#125;\n&#125;\n\nvue.config.js 中加入module.exports = &#123;\n   ...,\n   configureWebpack: &#123;\n      externals: &#123;\n        \"BMap\": \"BMap\"\n      &#125;\n   &#125;\n&#125;\n\n重新运行项目在组件中添加 import BMap from ‘BMap’\nonMounted(() => &#123;\n  var map = new BMap.Map(\"map\");\n  var point = new BMap.Point(116.404, 39.915);\n  map.centerAndZoom(point, 5);\n  map.addControl(new BMap.NavigationControl());\n&#125;);\n\n如果为 TSimport BMap from ‘BMap’报错\n解决：在 src 下新建文件 shims-BMap.d.ts 内容为declare module 'BMap' &#123;\n  const BMap: any\n  export default BMap\n&#125;\n\n参考取自：vue3 使用百度地图\n","slug":"evr2ba","date":"2021-08-19T03:19:10.000Z","categories_index":"问题记录","tags_index":"vue3,vue","author_index":"手可摘星陈"},{"id":"73b906900ddb1992b894f7b40254513c","title":"swiper在loop模式下获取当前下标","content":"前言\n\n\n\n\n\n\n\n\n项目需要根据轮播来改变对应背景和文字，所以需要获取当前轮播的下标。轮播是 水平卡片式轮播，教程在前文 vue 水平卡片式轮播\nloop 下 swiper6 获取当前轮播下标\n\n\n\n\n\n\n\n\n获取下标方式： this.activeIndex % length// 当前下标除以数组长度取余\n代码示例：new Swiper(\".swiper3\", &#123;\n  direction: \"horizontal\", //滑动方向，可设置水平(horizontal)或垂直(vertical)。\n  loop: true, // 设置为true 则开启loop模式\n  slidesPerView: \"auto\", // 设置slider容器能够同时显示的slides数量(carousel模式)。类型：number or auto\n  centeredSlides: true, // 设定为true时，active slide会居中，而不是默认状态下的居左。\n  spaceBetween: 20, // 在slide之间设置距离（单位px）。\n  autoplay: &#123;\n    // 设置为false，用户操作swiper之后自动切换不会停止\n    disableOnInteraction: false,\n  &#125;,\n  navigation: &#123;\n    nextEl: \".swiper-button-next\",\n    prevEl: \".swiper-button-prev\",\n  &#125;,\n  on: &#123;\n    // eslint-disable-next-line space-before-function-paren\n    slideChangeTransitionStart: function () &#123;\n      state.swiperIndex = this.activeIndex % state.swiperList.length;\n    &#125;,\n  &#125;,\n&#125;);\n","slug":"wv1yf2","date":"2021-08-18T07:40:00.000Z","categories_index":"问题记录","tags_index":"vue3,swiper6","author_index":"手可摘星陈"},{"id":"bba42ffdd017886e6e2fb7bd45b831c6","title":"vue相关问题合集","content":"vue2 和 vue3 router 更改 hash 模式前言项目部署到线上之后，发现刷新页面之后会 404，所以我们需要将 router 的模式从 history 换成 hash\n\n\n\n\n\n\n\n\n\n项目采用了 vue3+ts 框架\nvue2historyconst router = new VueRouter(&#123;\n  mode: 'history',\n  routes: [...]\n&#125;)\n\nhashconst router = new VueRouter(&#123;\n  mode: 'hash',  //或者把这句话注释，默认就是hash\n  routes: [...]\n&#125;)\n\nvue3history// 引入 createWebHistory\nimport &#123; createRouter, createWebHistory &#125; from \"vue-router\";\nconst router = createRouter(&#123;\n  history: createWebHistory(process.env.BASE_URL),\n  routes,\n&#125;);\n\nhash// 引入 createWebHashHistory\nimport &#123; createRouter, createWebHashHistory &#125; from \"vue-router\";\nconst router = createRouter(&#123;\n  history: createWebHashHistory(),\n  routes,\n&#125;);\n\nvue 遮罩层禁止滚动\n\n\n\n\n\n\n\n\n在遮罩层 div 添加 @touchmove.prevent @mousewheel.prevent\n\n\n\n\n\n\n\n\n\npc 端禁止遮罩层滚动\n//停止页面滚动\nstopMove()&#123;\n\tlet m =function(e)&#123;e.preventDefault();&#125;;\n\tdocument.body.style.overflow='hidden';\n\tdocument.addEventListener(\"touchmove\", m, false);//禁止页面滑动\n&#125;,\n\n//开启页面滚动\nMove()&#123;\n\tlet m =function(e)&#123;e.preventDefault();&#125;;\n\tdocument.body.style.overflow='';//出现滚动条\n\tdocument.removeEventListener(\"touchmove\", m, true);\n&#125;\n\nSyntax Error: Error: Node Sass does not yet support your current environment: OS X 64-bit with Unsupported runtime (102)\n\n\n\n\n\n\n\n\n遇到问题：\n\nSyntax Error: Error: Node Sass does not yet support your current environment: OS X 64-bit with Unsupported runtime (102)\nNode Sass 7.0.0 版本与^4.0.0 不兼容\n\n// 解决方法\n使用sass 卸载node-sass\n1. 使用npm\n // 卸载\n npm uninstall node-sass\n // 安装sass\n npm i -D sass\n2. 使用yarn\n // 卸载\n yarn remove node-sass\n // 安装sass\n yarn add -D sass\n\n在使用 yarn 安装依赖包时报错，提示信息：error An unexpected error occurred: “https://registry.yarnpkg.com/killable/-/killable-1.0.0.tgz: connect ETIMEDOUT 104.16.19.35:443”解决方案：\n\n\n\n\n\n\n\n\n运行命令，把资源地址设置成 npm 淘宝源\nnpm config set registry https://registry.npm.taobao.org\nnpm config set disturl https://npm.taobao.org/dist\n","slug":"hhwazy","date":"2021-08-18T03:42:00.000Z","categories_index":"问题记录","tags_index":"vue3,vue","author_index":"手可摘星陈"},{"id":"222dc9cc365798f93f2c01d1c0b50ede","title":"Hexo 叨叨点啥图床改为SM.MS","content":"简介\n\n\n\n\n\n\n\n\n按照叨叨点啥教程设置使用 7bu 图床，我上传图片的时候很多图片上传不成功所以我就自己修改图床\n本文中使用 SM.MS 图床\n叨叨点啥教程地址叨叨点啥教程\n教程先注册 SM.MS 账号修改 ios 图床地址\n\n\n\n\n\n\n\n\n把 7bu 图床的地址换成 SM.MS 的上传地址\n修改请求头和参数\n\n\n\n\n\n\n\n\n请求头添加 Authorization 后面文本粘贴你的 SM.MS token 值\n请求体改为 smfile改如下图圈起来的地方\n修改匹配正则表达式\n\n\n\n\n\n\n\n\n原匹配参数 (?&lt;=”url”:”).*(?=”/},)\n改为 (?&lt;=”url”:”).+?(?=”,”)如下图所示\n修改完成 可以上传图片了","slug":"xxwo2p","date":"2021-08-09T10:36:44.000Z","categories_index":"Hexo","tags_index":"Hexo","author_index":"手可摘星陈"},{"id":"cebfd5726c785c1656c2de1493058390","title":"vue水平卡片式轮播","content":"vue 水平卡片式轮播基于 vue3 + ts 开发的\n\n项目需要完成如上图的轮播，这是水平卡片式轮播。我的项目是基于 vue3+ts 开发的，我使用 swiper 来完成该轮播开发。具体代码如下文\n\n首先安装 swipernpm install swiper --save\n&#x2F;&#x2F; or\nyarn add swiper\n\nhtml 代码&lt;template>\n  &lt;div>\n    &lt;div class=\"examples\">\n      &lt;div class=\"bannerBox\">\n        &lt;div class=\"swiper-container swiper3\">\n          &lt;div class=\"swiper-wrapper\">\n            &lt;div\n              class=\"swiper-slide\"\n              v-for=\"(item, index) in banner\"\n              :key=\"index\"\n            >\n              &lt;img :src=\"item.picture_path\" alt=\"\" />\n            &lt;/div>\n          &lt;/div>\n          &lt;div class=\"swiper-pagination\">&lt;/div>\n          &lt;div class=\"swiper-button-prev swiper-button-white\">&lt;/div>\n          &lt;div class=\"swiper-button-next swiper-button-white\">&lt;/div>\n        &lt;/div>\n      &lt;/div>\n    &lt;/div>\n  &lt;/div>\n&lt;/template>\n\njavascript 代码&lt;script>\n// 有部分没用到你们可以不引用\nimport Swiper, &#123; Autoplay, EffectCoverflow, EffectCube, Pagination, Navigation &#125; from 'swiper';\nSwiper.use([Autoplay, EffectCoverflow, EffectCube, Pagination, Navigation]);\nimport 'swiper/swiper.min.css';\nimport 'swiper/components/navigation/navigation.scss';\nimport 'swiper/components/pagination/pagination.scss';\n\nexport default &#123;\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  data() &#123;\n    return &#123;\n      bannerIndex: 0,\n      banner: [\n        &#123;\n          picture_path: require('../../assets/home/home_bg.png')\n        &#125;,\n        &#123;\n          picture_path: require('../../assets/home/lunbo.png')\n        &#125;,\n        &#123;\n          picture_path: require('../../assets/home/home_bg2.png')\n        &#125;\n      ]\n    &#125;;\n  &#125;,\n  mounted() &#123;\n    let that = this;\n    let mySwiper = new Swiper('.swiper3', &#123;\n      direction: 'horizontal', //滑动方向，可设置水平(horizontal)或垂直(vertical)。\n      loop: true, // 设置为true 则开启loop模式\n      autoplay: true, // 自动切换时间\n      speed: 500, // 切换速度\n      slidesPerView: 'auto', // 设置slider容器能够同时显示的slides数量(carousel模式)。类型：number or auto\n      centeredSlides: true, // 设定为true时，active slide会居中，而不是默认状态下的居左。\n      spaceBetween: 10, // 在slide之间设置距离（单位px）。\n      loopAdditionaSlider: 0, // loop模式下会在slides前后复制若干个slide,，前后复制的个数不会大于原总个数。\n      navigation: &#123;\n        nextEl: '.swiper-button-next',\n        prevEl: '.swiper-button-prev',\n      &#125;,\n      pagination: &#123;\n        el: '.swiper-pagination',\n        type: 'fraction'\n      &#125;,\n    &#125;);\n  &#125;,\n&#125;;\n&lt;/script>\n\ncss 代码&lt;style lang=\"scss\" scoped>\n.examples&#123;\n  padding: 100px;\n&#125;\n.bannerTxt&#123;\n  height: 60px;\n  line-height: 60px;\n  text-align: center;\n  color: #666666;\n  font-size: 15px;\n&#125;\n.bannerIndex&#123;\n  line-height: 40px;\n  text-align: center;\n  color: #666666;\n  font-size: 15px;\n  text-align: center;\n  span&#123;\n    color: #b5654d;\n  &#125;\n&#125;\n.bannerBox&#123;\n  position: relative;\n  height: 490px;\n&#125;\n.swiper3 &#123;\n  width: 100%;\n  height: 100%;\n&#125;\n.swiper3 .swiper-wrapper .swiper-slide &#123;\n  width: 940px !important;\n  overflow: hidden;\n  display: flex;\n  align-items: center;\n  margin-right: 20px !important;\n&#125;\n.swiper3 .swiper-wrapper .swiper-slide img &#123;\n  width: 100%;\n  height: 490px;\n  border-radius: 5px;\n&#125;\n.swiper3 .swiper-wrapper .swiper-slide-prev,.swiper3 .swiper-wrapper .swiper-slide-next&#123;\n  height: 490px !important;\n  border-radius: 5px;\n  background: #000;\n  // margin-top: 20px;\n&#125;\n.swiper3 .swiper-wrapper .swiper-slide-prev img,.swiper3 .swiper-wrapper .swiper-slide-next img&#123;\n  opacity:0.6; filter: alpha(opacity=60);\n  width: 100%;\n  height: 100%;\n&#125;\n.swiper3 .swiper-pagination &#123;\n  color: #fff;\n&#125;\n&lt;/style>\n","slug":"gwcyel","date":"2021-07-20T06:36:55.000Z","categories_index":"Vue","tags_index":"vue,swiper6","author_index":"手可摘星陈"}]